// @hash v3-13462DE90AB70EE5D9146170129834889AC15BCF
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.development = new function () {
  this.$element = $("#client-development");
  this.$info = $('<div class="client-development">' + 'PROJECT CORTEX DEVELOPMENT' + '' + '</div>').css({
    "left": 0,
    "right": "initial"
  }).appendTo(Client.$element);
  this.$server = $('<p></p>').appendTo(this.$info);
  this.$uptime = $('<span></span>').appendTo(this.$server);
  this.$players = $('<span></span>').appendTo(this.$server).css({
    "margin-left": "6px",
    "float": "right"
  });
  const $stress = $('<br><p>Perform stress test</p>').css({
    "cursor": "pointer"
  }).appendTo(this.$info);
  $stress.on("click", async function () {
    const $content = $("<p>Performing a stress test on the client...<br><br></p>");
    Loader.setText($content);
    Loader.show();
    const room = RoomInterface.active;
    if (room) RoomInterface.stop();
    const start = performance.now();
    let assetStart = 0,
        assetSpritesStart = 0;

    for (let key in Assets.cache) {
      assetStart++;
      if (Assets.cache[key].sprites == undefined) continue;

      for (let sprite in Assets.cache[key].sprites) assetSpritesStart++;
    }

    let assetPromisesStart = 0;

    for (let key in Assets.promises) {
      if (Assets.cache[key].spritesheet != undefined) assetPromisesStart++;
      if (Assets.cache[key].manifest != undefined) assetPromisesStart++;
    }

    const $figures = $('<p></p>').appendTo($content);
    const figureStart = performance.now();
    const figures = ["hr", "hd", "ch", "lg", "sh"];
    let slowestFigure = null,
        fastestFigure = 100000;
    const figureRates = {};

    for (let index = 1; index < 1001; index++) {
      let string = [];

      for (let part in figures) string.push(figures[part] + "-" + Math.round(Math.random() * 100) + Math.round(Math.random() * 100));

      string = string.join('.');
      const figureRenderStart = performance.now();
      const figure = new FigureEntity(string, {
        direction: Math.round(Math.random() * 6)
      });
      await figure.process();
      await figure.render();
      const figureRenderEnd = performance.now();
      if (figureRates[string] == undefined) figureRates[string] = figureRenderEnd - figureRenderStart;
      if (figureRenderEnd - figureRenderStart > slowestFigure) slowestFigure = figureRenderEnd - figureRenderStart;
      if (figureRenderEnd - figureRenderStart < fastestFigure) fastestFigure = figureRenderEnd - figureRenderStart;
      $figures.html("Figure ticks: " + Math.round(performance.now() - figureStart) + ", renders: " + index + ", ~" + Math.round((performance.now() - figureStart) / index) + "ms/render, fastest ~" + Math.round(fastestFigure) + "ms, slowest ~" + Math.round(slowestFigure) + "ms");
    }

    const figureEnd = performance.now();
    const $furnitures = $('<p></p>').appendTo($content);
    const furnitureStart = performance.now();
    const furnitures = ["sound_set_5", "clothing_crookedhat", "limo_b_mid3", "ads_mirror", "hween_c16_floor2", "usva3_wallrug", "scifi_ltd17_mech", "santorini_c17_dividerend", "usva2_shelf2", "pixel_couch_black", "coco_sofa_c4", "school_stuff_02", "ny2015_chocfountain", "rainyday_c20_woodenfloor", "clothing_nt_moviestarmakeup", "highscore_perteam", "hc21_12", "ads_spang_sleep", "gld_gate", "summer_c17_merchstall", "hween13_thorndiv1", "bolly_desk", "statue_elk", "clothing_h20th", "wf_cnd_furnis_hv_avtrs", "hween13_castleturret1", "pet_waterbottle", "pirate_stage3_g", "xmas_c16_elf9", "ads_mtvtrophy_gold", "diamond_painting33", "xmas13_snowflake7", "bonusbag20_3", "val13_lamp", "jungle_c16_bkcase2", "horse_dye_16", "hween12_orb", "arabian_bigtb", "hblooza14_duckhook", "anc_waterfall", "neonpunk_c20_lights", "rare_colourable_pillar", "xmas14_gate2", "usva5_lamble", "hosptl_cab2", "paris_c15_pavement", "usva4_table", "ads_idol_l_carpet", "hotel_c18_cypress", "pixel_carpet_green", "mystics_rfountain", "wildwest_bank", "plant_pineapple", "clothing_demoneyes", "es_icestar", "usva4_rug", "room_gh15_cab5", "garden_chair", "newbie_present", "hween09_curt", "xm09_bauble_27", "lt_lava", "table_plasto4_bigsq", "xmas_c16_woodtile", "army15_poster", "easter_r16_squid", "hween_c19_bewitchedskull", "cland_c15_light", "attic15_clock", "sound_set_53", "market_c19_basket", "sf_wall", "bazaar_c17_dyepurple", "tray_cake", "garden_staringbush", "bb_apparatus", "classic8_disco", "chair_plasty4", "es_score_b", "wf_act_mute_triggerer", "cmp_fish_s", "vikings_wallshield_g", "room_wl15_deskfront", "tiki_gate", "sfx_dubstep3_2", "hs_applause", "cloud_throne", "pcnc_wall1", "cpunk_c15_neoarrowup", "bb_robo", "coralking_c18_angelfish", "room_wlof15_chair", "suncity_c19_wateroutlet", "val15_lilys", "classic7_stage", "cland15_ltd4", "elegant_c17_floor", "ads_ob_pillow", "val13_easel_4", "cland_c15_wall"];
    let slowestFurniture = null,
        fastestFurniture = 100000;
    const furnitureRates = {};

    for (let index = 1; index < 1001; index++) {
      const furnitureRenderStart = performance.now();
      let id = furnitures[Math.round(Math.random() * (furnitures.length - 1))];
      const furniture = new FurnitureEntity({
        id,
        direction: Math.round(Math.random() * 6),
        animation: Math.round(Math.random())
      });
      await furniture.process();
      await furniture.render();
      const furnitureRenderEnd = performance.now();
      if (furnitureRates[id] == undefined) furnitureRates[id] = furnitureRenderEnd - furnitureRenderStart;
      if (furnitureRenderEnd - furnitureRenderStart > slowestFurniture) slowestFurniture = furnitureRenderEnd - furnitureRenderStart;
      if (furnitureRenderEnd - furnitureRenderStart < fastestFurniture) fastestFurniture = furnitureRenderEnd - furnitureRenderStart;
      $furnitures.html("Furniture ticks: " + Math.round(performance.now() - furnitureStart) + ", renders: " + index + ", ~" + Math.round((performance.now() - furnitureStart) / index) + "ms/render, fastest ~" + Math.round(fastestFurniture) + "ms, slowest ~" + Math.round(slowestFurniture) + "ms");
    }

    const furnitureEnd = performance.now();
    const end = performance.now();
    let assetEnd = 0,
        assetSpritesEnd = 0;

    for (let key in Assets.cache) {
      assetEnd++;
      if (Assets.cache[key].sprites == undefined) continue;

      for (let sprite in Assets.cache[key].sprites) assetSpritesEnd++;
    }

    let assetPromisesEnd = 0;

    for (let key in Assets.promises) {
      if (Assets.cache[key].spritesheet != undefined) assetPromisesEnd++;
      if (Assets.cache[key].manifest != undefined) assetPromisesEnd++;
    }

    $("<p><br>" + (assetEnd - assetStart) + " new assets, " + (assetPromisesEnd - assetPromisesStart) + " new downloads, " + (assetSpritesEnd - assetSpritesStart) + " new sprites...</p>").appendTo($content);
    $("<p><br>Finished stress test after " + Math.round(end - start) + "ms!</p>").appendTo($content);
    await SocketMessages.sendCall({
      OnStressTest: {
        count: end - start,
        figures: {
          count: figureEnd - figureStart,
          rates: figureRates
        },
        furnitures: {
          count: furnitureEnd - furnitureStart,
          rates: furnitureRates
        },
        assets: {
          count: assetEnd - assetStart,
          downloads: assetPromisesEnd - assetPromisesStart,
          sprites: assetSpritesEnd - assetSpritesStart
        }
      }
    }, "OnStressTest");
    if (room) RoomInterface.start();
    setTimeout(function () {
      Loader.hide();
    }, 1000);
  });
  this.$stats = $('<div class="client-development">' + 'PROJECT CORTEX HOBBA ACCESS' + '</div>').appendTo(Client.$element);
  this.$debug = $('<p></p>').appendTo(this.$stats);
  this.$frames = $('<span></span>').appendTo(this.$debug);
  this.$network = $('<span></span>').appendTo(this.$debug).css({
    "margin-left": "6px",
    "float": "right"
  });
}();
Client.development.frames = new function () {
  $(window).on("wheel", function (event) {
    if (!event.shiftKey) return;
    const direction = event.originalEvent.deltaY < 0 ? 1 : -1;
    if (!RoomInterface.active) return;
    RoomInterface.frameLimit += direction;
  });
}();
Loader.ready(function () {
  Client.development.furni = new function () {
    const entity = new Dialog({
      title: "Loading",
      size: {
        width: 400
      },
      offset: {
        type: "absolute",
        left: "10px",
        top: "50px"
      }
    });
    entity.events.create.push(function () {});

    entity.set = async function (furniture) {
      entity.show();
      entity.pause();
      entity.$content.html("");
      const data = await Furnitures.get(furniture.data.furniture);
      const depth = await SocketMessages.sendCall({
        OnFurnitureDepthRequest: data.id
      }, "OnFurnitureDepthRequest");
      $('<div class="dialog-property">' + '<p>' + '<b>Furniture Depth</b>' + '<span>How high the furniture is in units!</span>' + '</p>' + '<div class="input-pen">' + '<input class="furniture-depth" type="text" placeholder="Enter a furniture depth..." value="' + depth + '">' + '</div>' + '</div>').appendTo(entity.$content).find(".furniture-depth").on("change", async function () {
        await SocketMessages.sendCall({
          Temp_DevFurniUpdate: {
            id: data.id,
            depth: parseFloat($(this).val())
          }
        }, "Temp_DevFurniUpdate");
      });
      const logic = await SocketMessages.sendCall({
        OnFurnitureLogicRequest: data.id
      }, "OnFurnitureLogicRequest");
      $('<div class="dialog-property">' + '<p>' + '<b>Furniture Logic</b>' + '<span>What logic does the use on the server?</span><br>' + '<i>Changing this can cause unwanted alterations!</i>' + '</p>' + '<div class="input-pen">' + '<input class="furniture-logic" type="text" placeholder="Enter a furniture logic..." value="' + logic + '">' + '</div>' + '</div>').appendTo(entity.$content).find(".furniture-logic").on("change", async function () {
        await SocketMessages.sendCall({
          Temp_DevFurniUpdate: {
            id: data.id,
            logic: $(this).val()
          }
        }, "Temp_DevFurniUpdate");
      });
      const flags = await SocketMessages.sendCall({
        OnFurnitureFlagsRequest: data.id
      }, "OnFurnitureFlagsRequest");
      const $flags = $('<div class="dialog-property">' + '<p>' + '<b>Furniture Flags</b>' + '</p>' + '</div>').appendTo(entity.$content);
      const $checkboxes = $('<div></div>').appendTo($flags);
      $('<input type="checkbox" id="stackable" style="width: auto"' + (flags & FurnitureFlags.stackable ? " checked" : "") + '>' + '<label for="stackable"> Stackable</label>').appendTo($checkboxes).on("change", async function () {
        await SocketMessages.sendCall({
          Temp_DevFurniUpdate: {
            id: data.id,
            stackable: $(this).val()
          }
        }, "Temp_DevFurniUpdate");
      });
      $('<input type="checkbox" id="sitable" style="width: auto"' + (flags & FurnitureFlags.sitable ? " checked" : "") + '>' + '<label for="sitable"> Sitable</label>').appendTo($checkboxes).on("change", async function () {
        await SocketMessages.sendCall({
          Temp_DevFurniUpdate: {
            id: data.id,
            sitable: $(this).val()
          }
        }, "Temp_DevFurniUpdate");
      });
      $('<input type="checkbox" id="standable" style="width: auto"' + (flags & FurnitureFlags.standable ? " checked" : "") + '>' + '<label for="standable"> Standable</label>').appendTo($checkboxes).on("change", async function () {
        await SocketMessages.sendCall({
          Temp_DevFurniUpdate: {
            id: data.id,
            standable: $(this).val()
          }
        }, "Temp_DevFurniUpdate");
      });
      $('<input type="checkbox" id="walkable" style="width: auto"' + (flags & FurnitureFlags.walkable ? " checked" : "") + '>' + '<label for="walkable"> Walkable</label>').appendTo($checkboxes).on("change", async function () {
        await SocketMessages.sendCall({
          Temp_DevFurniUpdate: {
            id: data.id,
            walkable: $(this).val()
          }
        }, "Temp_DevFurniUpdate");
      });
      $('<input type="checkbox" id="sleepable" style="width: auto"' + (flags & FurnitureFlags.sleepable ? " checked" : "") + '>' + '<label for="sleepable"> Sleep</label>').appendTo($checkboxes).on("change", async function () {
        await SocketMessages.sendCall({
          Temp_DevFurniUpdate: {
            id: data.id,
            sleepable: $(this).val()
          }
        }, "Temp_DevFurniUpdate");
      });
      Client.development.furni.unpause();
      entity.setTitle('HabboFurnitures/' + data.line + '/' + data.id);
    };

    return entity;
  }();
  RoomInterface.cursor.events.click.push(function (entity) {
    Client.development.furni.hide();
  });
});
Loader.ready(function () {
  Client.development.shop = new function () {
    const entity = new Dialog({
      title: "Loading",
      size: {
        width: 400,
        height: 80
      },
      offset: {
        type: "absolute",
        left: "10px",
        top: "250px"
      }
    });
    entity.events.create.push(function () {});

    entity.set = async function (page) {
      entity.show();
      entity.pause();
      entity.$content.html("");
      $('<div class="dialog-property">' + '<p>' + '<b>Shop Icon</b>' + '<span>What icon identifier the page uses!</span>' + '</p>' + '<div class="input-pen">' + '<input class="page-icon" type="text" placeholder="Enter a page icon..." value="' + page.icon + '">' + '</div>' + '</div>').appendTo(entity.$content).find(".page-icon").on("change", async function () {
        const icon = parseInt($(this).val());
        await SocketMessages.sendCall({
          Temp_DevShopUpdate: {
            id: page.id,
            icon: icon
          }
        }, "Temp_DevShopUpdate");
        page.icon = icon;
        Client.shop.setPage(page.parent);
        Client.shop.setPage(page.id);
      });
      Client.development.shop.unpause();
      entity.setTitle('HabboShopPages/' + page.title);
    };

    return entity;
  }();
});// @hash v3-40616FCD1A2FAE665FFA3D35DF893E2137E29E71
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Keys {}

_defineProperty(Keys, "down", {});

;
$(window).on("keydown", function (event) {
  Keys.down[event.code] = performance.now();
});
$(window).on("keyup", function (event) {
  delete Keys.down[event.code];
});
$(window).on("blur", function () {
  for (let key in Keys.down) delete Keys.down[key];
});// @hash v3-B4B659B6DC212D53D984F55787502806B2DD638F
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Socket {}

_defineProperty(Socket, "connected", false);

_defineProperty(Socket, "sent", 0);

_defineProperty(Socket, "received", 0);

_defineProperty(Socket, "open", function (url = "ws" + (Loader.settings.socket.ssl ? "s" : "") + "://" + Loader.settings.socket.address + ":" + Loader.settings.socket.port + "/" + key) {
  return new Promise(function (resolve, failure) {
    console.log("[%cSocket%c]%c Connecting to the server at " + url + "...", "color: orange", "color: inherit", "color: lightblue");
    const timestamp = performance.now();
    const server = new WebSocket(url);

    server.onopen = function () {
      Socket.connected = true;
      console.log("[%cSocket%c]%c Connected to the server after " + Math.floor(performance.now() - timestamp) + "ms!", "color: orange", "color: inherit", "color: lightblue");

      server.onopen = function () {};

      server.onclose = function () {
        if (!Socket.connected) return;
        Socket.connected = false;
        Loader.setError("Lost connection with the server...");
        Loader.show();
      };

      SocketMessages.block("OnSocketPing");
      setInterval(async function () {
        const time = Date.now();
        const tick = performance.now();
        const received = Socket.received;
        const result = await SocketMessages.sendCall({
          OnSocketPing: null
        }, "OnSocketPing");
        const sent = Socket.sent; //console.log("[%cSocketNetwork%c]%c Communicated ping " + (Math.round((performance.now() - tick) *  100) / 100) + "ms (to " + Math.round(result.time - time) + "ms, from " + Math.round(Date.now() - result.time) + "ms); sent " + sent + "/" + result.received + "; received " + received + "/" + result.sent, "color: orange", "color: inherit", "color: lightblue");

        Client.development.$network.text("Ping " + Math.round((performance.now() - tick) * 100) / 100 + "ms");
      }, 1000);
      SocketMessages.block("OnSocketUpdate");
      SocketMessages.register("OnSocketUpdate", function (data) {
        Client.development.$uptime.html("Uptime: " + data.uptime + "");
        Client.development.$players.html("(" + data.users + " users)");
      });
      resolve(server);
    };

    server.onmessage = function (data) {
      Socket.received++;
      const message = JSON.parse(data.data);

      for (let key in message) SocketMessages.call(key, message[key]);
    };

    server.onclose = function () {
      console.log("[%cSocket%c]%c Failed to connect to the server after " + Math.floor(performance.now() - timestamp) + "ms!", "color: orange", "color: inherit", "color: lightblue");
      failure(server);
    };
  });
});

;// @hash v3-F6F2FFDE0021D8F258E453C4B837B40FD1D0C496
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class SocketMessages {
  static register(event, callback) {
    if (SocketMessages.events[event] == undefined) {
      SocketMessages.events[event] = []; //Client.utils.log("SocketMessages", "Registered a new event handler for " + event + "!");
    }

    const index = SocketMessages.events[event].push(callback); //Client.utils.log("SocketMessages", "Registered event handler " + index + " for " + event + "!");
  }

  static unregister(event, callback) {
    if (SocketMessages.events[event] == undefined) return;
    const index = SocketMessages.events[event].indexOf(callback);
    if (index == -1) return;
    SocketMessages.events[event].splice(index, 1); //Client.utils.log("SocketMessages", "Unregistered event handler " + index + " for " + event + "!");

    if (SocketMessages.events[event].length == 0) delete SocketMessages.events[event];
  }

  static send(message) {
    Socket.sent++;
    Socket.server.send(JSON.stringify(message));
  }

  static sendCall(message, event, correct = undefined) {
    return new Promise(function (resolve) {
      const task = function (data) {
        if (correct != undefined && correct(data) == 0) return;
        SocketMessages.unregister(event, task);
        resolve(data);
      };

      SocketMessages.register(event, task);
      SocketMessages.send(message);
    });
  }

  static block(event) {
    SocketMessages.blocks[event] = 1;
  }

  static call(event, data) {
    if (SocketMessages.blocks[event] != 1) console.log("[%cSocketMessage%c]%c Received " + event + " from the server: %o", "color: orange", "color: inherit", "color: lightblue", data);
    if (SocketMessages.events[event] == undefined) console.warn("[%cSocketMessage%c]%c Event " + event + " does not have any client handlers!", "color: orange", "color: inherit", "color: lightblue");

    for (let index in SocketMessages.events[event]) SocketMessages.events[event][index](data);
  }

}

_defineProperty(SocketMessages, "events", {});

_defineProperty(SocketMessages, "blocks", {});

;// @hash v3-BD13DDEAABB58087DAC38963888E7E1269B78B56
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Assets {
  static async getManifest(asset, library = true) {
    if (Assets.cache[asset] == undefined) Assets.cache[asset] = {};
    if (Assets.cache[asset].manifest != undefined) return Assets.cache[asset].manifest;
    await Assets.downloadManifest(asset, library);
    return Assets.cache[asset].manifest;
  }

  static async downloadManifest(asset, library = true) {
    const name = asset.substring(asset.lastIndexOf('/') + 1);
    const path = Loader.settings.cdn + (library ? "assets/" + asset + "/" + name + ".json" : "assets/" + asset + ".json");
    if (Assets.promises[asset] == undefined) Assets.promises[asset] = {};
    if (Assets.promises[asset] == undefined) Assets.promises[asset] = {};

    if (Assets.promises[asset].manifest != undefined) {
      return new Promise(function (resolve) {
        Assets.promises[asset].manifest.push(function () {
          resolve();
        });
      });
    }

    Assets.promises[asset].manifest = [];
    return new Promise(function (resolve) {
      $.getJSON(path, function (manifest) {
        Assets.cache[asset].manifest = manifest;

        for (let index in Assets.promises[asset].manifest) Assets.promises[asset].manifest[index]();

        resolve();
      }).fail(function () {
        Assets.cache[asset].manifest = {};

        for (let index in Assets.promises[asset].manifest) Assets.promises[asset].manifest[index]();

        resolve();
      });
    });
  }

  static async getSpritesheet(asset, library = true) {
    if (Assets.cache[asset] == undefined) Assets.cache[asset] = {};
    if (Assets.cache[asset].spritesheet != undefined) return Assets.cache[asset].spritesheet;
    await Assets.downloadSpritesheet(asset, library);
    return Assets.cache[asset].spritesheet;
  }

  static async downloadSpritesheet(asset, library = true) {
    const name = asset.substring(asset.lastIndexOf('/') + 1);
    let path = Loader.settings.cdn + (library ? "assets/" + asset + "/" + name : "assets/" + asset);
    if (library == true || asset.indexOf('.') == -1) path += ".png";
    if (Assets.promises[asset] == undefined) Assets.promises[asset] = [];

    if (Assets.promises[asset].spritesheet != undefined) {
      return new Promise(function (resolve) {
        Assets.promises[asset].spritesheet.push(function () {
          resolve();
        });
      });
    }

    Assets.promises[asset].spritesheet = [];
    return new Promise(function (resolve) {
      const image = new Image();

      image.onload = function () {
        Assets.cache[asset].spritesheet = image;

        for (let index in Assets.promises[asset].spritesheet) Assets.promises[asset].spritesheet[index]();

        resolve();
      };

      image.onerror = function () {
        Assets.cache[asset].spritesheet = image;

        for (let index in Assets.promises[asset].spritesheet) Assets.promises[asset].spritesheet[index]();

        resolve();
      };

      image.src = path;
    });
  }

  static async getSprite(asset, sprite, flipped = false) {
    const manifest = await Assets.getManifest(asset);
    const spritesheet = await Assets.getSpritesheet(asset);
    if (Assets.cache[asset].sprites == undefined) Assets.cache[asset].sprites = {};
    if (Assets.cache[asset].spritesData == undefined) Assets.cache[asset].spritesData = {};
    if (Assets.cache[asset].sprites[sprite + (flipped == true ? "?flipped=true" : "")] != undefined) return Assets.cache[asset].sprites[sprite + (flipped == true ? "?flipped=true" : "")];
    const data = manifest.sprites[sprite];

    if (data == undefined) {
      console.warn("[Assets] " + sprite + " in library " + asset + " does not exist!");
      return null;
    }

    if (data.link != undefined) {
      for (let key in manifest.sprites[data.link]) data[key] = manifest.sprites[data.link][key];

      delete data.link;
    }

    const $canvas = $('<canvas width="' + data.width + '" height="' + data.height + '"></canvas>');
    const context = $canvas[0].getContext("2d");
    context.drawImage(spritesheet, parseInt(data.left), parseInt(data.top), parseInt(data.width), parseInt(data.height), 0, 0, parseInt(data.width), parseInt(data.height));
    Assets.cache[asset].sprites[sprite] = $canvas[0];

    if (flipped == true) {
      const $flippedCanvas = $('<canvas width="' + data.width + '" height="' + data.height + '"></canvas>');
      const flippedContext = $flippedCanvas[0].getContext("2d");
      flippedContext.translate(flippedContext.canvas.width, 0);
      flippedContext.scale(-1, 1);
      flippedContext.drawImage($canvas[0], 0, 0);
      Assets.cache[asset].sprites[sprite + "?flipped=true"] = $flippedCanvas[0];
      return Assets.cache[asset].sprites[sprite + "?flipped=true"];
    }

    return Assets.cache[asset].sprites[sprite];
  }

  static async getSpriteData(asset, sprite) {
    const image = await Assets.getSprite(asset, sprite);
    if (Assets.cache[asset].spritesData[sprite] != undefined) return Assets.cache[asset].spritesData[sprite];
    Assets.cache[asset].spritesData[sprite] = image.getContext("2d").getImageData(0, 0, image.width, image.height);
    return Assets.cache[asset].spritesData[sprite];
  }

  static async getSpriteColor(asset, sprite, color) {
    const image = await Assets.getSprite(asset, sprite);
    if (Assets.cache[asset].sprites[sprite + "?color=" + color] != undefined) return Assets.cache[asset].sprites[sprite + "?color=" + color];
    const $colorCanvas = $('<canvas width="' + image.width + '" height="' + image.height + '"></canvas>');
    const colorContext = $colorCanvas[0].getContext("2d");
    colorContext.drawImage(image, 0, 0);
    colorContext.globalCompositeOperation = "multiply";
    colorContext.fillStyle = color.replace('0x', '#');
    colorContext.fillRect(0, 0, image.width, image.height);
    const $canvas = $('<canvas width="' + image.width + '" height="' + image.height + '"></canvas>');
    const context = $canvas[0].getContext("2d");
    context.drawImage(image, 0, 0);
    context.globalCompositeOperation = "source-in";
    context.drawImage($colorCanvas[0], 0, 0);
    Assets.cache[asset].sprites[sprite + "?color=" + color] = $canvas[0];
    return Assets.cache[asset].sprites[sprite + "?color=" + color];
  }

}

_defineProperty(Assets, "cache", {});

_defineProperty(Assets, "promises", {});

;// @hash v3-C7A81D43A405DF63320E469D0AEA1DD474870B1C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Game {
  static async getUser(id) {
    if (Game.users[id] != undefined) return Game.users[id];

    if (Game.promises.users[id] != undefined) {
      return new Promise(function (resolve) {
        Game.promises.users[id].push(function (data) {
          resolve(data);
        });
      });
    }

    Game.promises.users[id] = [];
    Game.users[id] = await SocketMessages.sendCall({
      OnUserRequest: id
    }, "OnUserRequest", x => x.id == id);

    for (let index in Game.promises.users[id]) Game.promises.users[id][index](Game.users[id]);

    return Game.users[id];
  }

}

_defineProperty(Game, "users", {});

_defineProperty(Game, "promises", {
  users: {}
});

;// @hash v3-B114777ED814B798337C963AB61F2B9203163F7C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Dialogs {
  static sort() {
    Dialogs.entities.sort(function (a, b) {
      return a.timestamp - b.timestamp;
    });

    for (let index in Dialogs.entities) Dialogs.entities[index].$element?.css("z-index", 1 + index);
  }

  static add(entity) {
    Dialogs.entities.push(entity);
    entity.events.show.push(function () {
      entity.timestamp = performance.now();
      Dialogs.sort();
    });
  }

}

_defineProperty(Dialogs, "$element", $('<div id="dialogs"></div>').appendTo(Client.$element));

_defineProperty(Dialogs, "entities", []);

;
$(window).on("keyup", function (event) {
  if (event.code != "Escape") return;
  let current = -1;

  for (let index = Dialogs.entities.length - 1; index != -1; index--) {
    if (!Dialogs.entities[index].active) continue;
    current = index;
    break;
  }

  if (current == -1) return;
  Dialogs.entities[current].hide();

  for (let index = current - 1; index != -1; index--) {
    if (!Dialogs.entities[index].active) continue;
    Dialogs.entities[index].show();
    break;
  }
});// @hash v3-6D8A52A9B6640EDC0740EBA6BABC102689518260
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Dialog {
  constructor(settings = {}) {
    _defineProperty(this, "resizableMouseDown", false);

    _defineProperty(this, "resizableMousePosition", {
      left: null,
      top: null
    });

    _defineProperty(this, "resizableMousePositionStart", {
      left: null,
      top: null
    });

    _defineProperty(this, "resizableOnMouseMoveAlias", null);

    _defineProperty(this, "resizableOnMouseUpAlias", null);

    _defineProperty(this, "resizableOnMouseDownAlias", null);

    this.events = {
      show: [],
      hide: [],
      create: [],
      destroy: []
    };
    this.active = false;
    this.created = false;
    this.size = {
      width: settings.size.width || "auto",
      height: settings.size.height || "auto"
    };
    this.offset = settings.offset || {
      type: "center",
      left: 0,
      top: 0
    };
    this.title = settings.title || "Loading...";
    this.resizable = settings.resizable || false;
    Dialogs.add(this);
  }

  create() {
    if (this.created) return;
    this.created = true;
    this.$element = $(`
            <div class="dialog-default">
                <div class="dialog-default-header">
                    <p class="dialog-default-header-title">Loading...</p>

                    <div class="dialog-default-header-buttons">
                        <div class="dialog-default-header-info"></div>
                        <div class="dialog-default-header-close"></div>
                    </div>
                </div>

                <div class="dialog-default-container">
                    <div class="dialog-default-content"></div>

                    <div class="dialog-default-overlay"></div>
                </div>  
            </div>
        `).draggable({
      handle: ".dialog-default-header"
    }).css("position", "absolute").on("mousedown", event => {
      this.timestamp = performance.now();
      Dialogs.sort();
    }).on("click", ".dialog-default-header-close", event => this.destroy()).appendTo(Dialogs.$element);
    this.$title = this.$element.find(".dialog-default-header-title");
    this.$container = this.$element.find(".dialog-default-container");
    this.$content = this.$element.find(".dialog-default-content");
    this.$overlay = this.$element.find(".dialog-default-overlay");
    this.setTitle(this.title);
    this.setSize(this.size.width, this.size.height);
    this.setOffset(this.offset.type, this.offset.left, this.offset.top);
    this.setResizable(this.resizable);

    for (let index in this.events.create) this.events.create[index]();
  }

  show() {
    this.create();
    this.active = true;

    for (let index in this.events.show) this.events.show[index]();

    this.$element.show();
  }

  hide() {
    if (!this.active) return;
    this.active = false;

    for (let index in this.events.hide) this.events.hide[index]();

    this.$element.hide();
  }

  toggle() {
    return !this.active ? this.show() : this.hide();
  }

  destroy() {
    this.hide();
    if (!this.created) return;
    this.created = false;
    this.$element.remove();
    delete this.$element;

    for (let index in this.events.destroy) this.events.destroy[index]();
  }

  pause() {
    if (!this.created) return;
    this.$overlay.show();
    this.$title.text("Loading...");
  }

  unpause() {
    if (!this.created) return;
    this.$overlay.hide();
    this.$title.text(this.title);
  }

  setTitle(title) {
    this.title = title;
    this.$title.text(this.title);
  }

  setSize(width, height = width) {
    this.width = width;
    this.height = height;
    this.$container.css({
      "width": width,
      "height": height,
      "min-width": width,
      "min-height": height
    });
  }

  setOffset(type, left = 0, top = 0) {
    if (type == "center") return this.setOffset("absolute", this.$element.parent().width() / 2 - this.$element.width() / 2 + left, this.$element.parent().height() / 2 - this.$element.height() / 2 + top);
    this.$element.css({
      "left": left,
      "top": top
    });
  }

  resizableOnMouseDown(event) {
    this.resizableMouseDown = true;
    this.resizableMousePositionStart = {
      left: event.clientX,
      top: event.clientY
    };
    this.resizableMousePosition = {
      left: event.clientX,
      top: event.clientY
    };

    this.resizableOnMouseMoveAlias = event => this.resizableOnMouseMove(event);

    this.resizableOnMouseUpAlias = event => this.resizableOnMouseUp(event);

    $(window).bind("mousemove", this.resizableOnMouseMoveAlias);
    $(window).bind("mouseup", this.resizableOnMouseUpAlias);
  }

  resizableOnMouseMove(event, width, height) {
    if (this.$container.width() > this.width || event.clientX >= this.resizableMousePositionStart.left) this.$container.css({
      "width": "+=" + (event.clientX - this.resizableMousePosition.left)
    });
    if (this.$container.height() > this.height || event.clientY >= this.resizableMousePositionStart.top) this.$container.css({
      "height": "+=" + (event.clientY - this.resizableMousePosition.top)
    });
    this.resizableMousePosition = {
      left: event.clientX,
      top: event.clientY
    };
  }

  resizableOnMouseUp(event) {
    this.resizableMouseDown = false;
    $(window).unbind("mousemove", this.resizableOnMouseMoveAlias);
    $(window).unbind("mouseup", this.resizableOnMouseUpAlias);
  }

  setResizable(enabled = true) {
    if (enabled) {
      this.$resizable = $('<div class="dialog-default-resizable"></div>').appendTo(this.$element);

      this.resizableOnMouseDownAlias = event => this.resizableOnMouseDown(event);

      this.$resizable.bind("mousedown", this.resizableOnMouseDownAlias);
    } else {
      this.$resizable?.unbind("mousedown", this.resizableOnMouseDownAlias).remove();
      $(window).unbind("mousemove", this.resizableOnMouseMoveAlias);
      $(window).unbind("mouseup", this.resizableOnMouseUpAlias);
    }

    this.resizable = enabled;
  }

}

;// @hash v3-C326231328636EB125A95AEB20CAA518B83B9359
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
class CameraDialog extends Dialog {
  create() {
    super.create();
    this.$element.addClass("dialog-camera");
    this.$grid = $('<div class="dialog-camera-grid"></div>').appendTo(this.$content);
  }

}

;// @hash v3-2BBCC8B17DBB6B053BE1CEC45CC6C44AE4DD7E4D
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
class DialogHeader {
  constructor(settings = {}) {
    this.$element = $('<div class="dialog-header"></div>');
    this.$image = $('<canvas class="dialog-header-image"></canvas>').appendTo(this.$element);
    this.$content = $('<div class="dialog-header-container">' + '<div class="dialog-header-content">' + '<div class="dialog-header-icon"></div>' + '<div class="dialog-header-details">' + '<h1 class="dialog-header-title"></h1>' + '<p class="dialog-header-description"></p>' + '</div>' + '</div>' + '</div>').appendTo(this.$element);
    this.set(settings);
  }

  setTitle(title) {
    this.$content.find(".dialog-header-title").html(title);
  }

  setDescription(description) {
    this.$content.find(".dialog-header-description").html(description);
  }

  getContext(context) {
    this.$image.attr({
      width: this.$image.parent().width(),
      height: this.$image.parent().height()
    });
    return this.$image[0].getContext(context);
  }

  setIcon($element) {
    const $icon = this.$content.find(".dialog-header-icon").css("min-width", "64px");
    $icon.html("");
    $element.appendTo($icon);
  }

  set(settings) {
    if (settings.height != undefined) this.$element.css("height", settings.height);
  }

}

;// @hash v3-BC7922BA9254B6DC1F2B9B62F7D817C6CC2FC910
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class DialogTabs {
  constructor(height) {
    _defineProperty(this, "callbacks", []);

    this.$element = $('<div class="dialog-tabs">' + '<div class="dialog-tabs-container" style="height: ' + height + 'px"></div>' + '</div>');
    this.$header = $('<div class="dialog-tabs-header"></div>').prependTo(this.$element);
    this.$content = $('<div class="dialog-tabs-content"></div>').appendTo(this.$element.find(".dialog-tabs-container"));
    this.buttons = {};
  }

  add(identifier, text, callback = undefined, disabled = false) {
    const $element = $('<div class="dialog-tabs-button">' + text + '</div>').appendTo(this.$header);

    if (disabled) {
      $element.css({
        "pointer-events": "none",
        "opacity": .5
      });
    }

    this.buttons[identifier] = {
      element: $element,
      callback: callback
    };
    const entity = this;
    $element.on("click", function () {
      entity.show(identifier);
    });
  }

  hide() {
    this.$header.find(".dialog-tabs-button[active]").removeAttr("active");
    this.$content.html("");
  }

  async show(identifier = this.selected) {
    if (identifier == undefined) return;
    this.hide();
    this.buttons[identifier].element.attr("active", "");
    this.$content.html("");

    for (let index in this.callbacks) await this.callbacks[index](identifier, this.$content);

    if (this.buttons[identifier].callback != undefined) this.buttons[identifier].callback(this.$content);
    this.selected = identifier;
  }

  click(callback) {
    this.callbacks.push(callback);
  }

}

;// @hash v3-F842724389A60D946A041B63C83D1A336E324DAE
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
class DialogSelection {
  constructor(placeholder, options = []) {
    this.$element = $('<div class="dialog-selection">' + '<div class="dialog-selection-placeholder">' + placeholder + '</div>' + '<div class="dialog-selection-options"></div>' + '</div>');
    this.$placeholder = this.$element.find(".dialog-selection-placeholder");
    const $options = this.$element.find(".dialog-selection-options");
    this.$placeholder.on("click", function () {
      $options.toggle();
    });

    for (let index in options) {
      const $option = $('<div class="dialog-selection-option" value="' + options[index].value + '">' + options[index].text + '</div>').appendTo($options);
      $option.on("click", () => {
        $(this).parent().find(".dialog-selection-option.active").removeClass("active");
        $(this).addClass("active");
        this.$placeholder.text($(this).text()).attr("value", $(this).attr("value"));
        $options.hide();
      });
    }
  }

  value() {
    return this.$placeholder.attr("value");
  }

}

;// @hash v3-25BF6D2822FFE82F9E7B40ED58B06F29220A6808
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
class DisplayDialog extends Dialog {
  constructor(settings = {}) {
    settings.offset = {
      type: "center"
    };
    settings.size = {
      width: 420,
      height: 220
    };
    super(settings);
  }

  create() {
    super.create();
    this.$element.addClass("dialog-display");
    this.events.create.push(function () {
      this.$header = $('<div class="dialog-display-header"></div>').appendTo(this.$content);
      const $display = $('<div class="dialog-display-content"></div>').appendTo(this.$header);
      const $container = $('<div class="dialog-display-header-info"></div>').appendTo(this.$header);
      this.$info = $('<div class="dialog-display-header-info-content"></div>').appendTo($container);
      $('<div class="dialog-display-content-star"></div>').appendTo($display);
      this.$display = $('<div class="dialog-display-content-item"></div>').appendTo($display);
      const $button = $('<div class="dialog-button">Okay!</div>').appendTo(this.$content);
      $button.on("click", function () {
        this.hide();
      });
    });
    this.events.show.push(function () {
      if (this.$effects != undefined) {
        this.$effects.remove();
        delete this.$effects;
      }

      this.$effects = $('<div class="dialog-display-content-effects"></div>').appendTo(this.$display);
      const sizes = ["small", "small", "medium", "big"];

      for (let index = 0; index < 20; index++) {
        setTimeout(function () {
          const $effect = $('<div class="dialog-display-content-effect"></div>').appendTo(this.$effects);
          $effect.css({
            "left": 3 + Math.floor(Math.random() * 9) * 10 + "px",
            "top": 3 + Math.floor(Math.random() * 9) * 10 + "px"
          });
          $effect.addClass("sprite-display-effect-" + sizes[Math.floor(Math.random() * sizes.length)]);
          $effect.fadeIn(Math.floor(Math.random() * 500), function () {
            setTimeout(function () {
              $effect.fadeOut(Math.floor(Math.random() * 500));
            }, Math.floor(Math.random() * 5000));
          });
        }, Math.floor(Math.random() * 1500));
      }
    });
  }

}

;// @hash v3-23BCA55A45B20AF45D153CA375E0A57CA4A6A05A
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Figures {
  static getPartName(part) {
    // "bd","sh","lg","ch","wa","ca","hd","fc","ey","hr","hrb","fa","ea","ha","he"
    switch (part) {
      case "li":
      case "lh":
      case "ls":
        return "LeftArm";

      case "ri":
      case "rh":
      case "rs":
        return "RightArm";

      case "bd":
      case "lg":
        return "Torso";
    }

    return "Body";
  }

  static async getLibrary(id, type) {
    const libraries = Figures.map.map.lib;
    let index = 0;

    for (index in libraries) {
      if (libraries[index].part.length == undefined) libraries[index].part = [libraries[index].part];

      for (let part in libraries[index].part) {
        if (libraries[index].part[part].id == id && libraries[index].part[part].type[0] == type[0] && libraries[index].part[part].type[1] == type[1]) {
          return libraries[index].id;
        }
      }
    }

    return libraries[index].id;
  }

  static async getSetType(type) {
    const sets = Figures.data.figuredata.sets.settype;
    let index = 0;

    for (index in sets) {
      if (sets[index].type != type) continue;
      break;
    }

    return sets[index];
  }

  static async getSetData(set, id) {
    let index = 0;

    for (index in set.set) {
      if (set.set[index].id != id) continue;
      break;
    }

    return set.set[index];
  }

  static getSprite(asset, sprite) {
    const assets = asset.manifest.manifest.library.assets.asset;
    let index = 0;

    for (index in assets) {
      if (assets[index].name != sprite) continue;
      break;
    }

    return assets[index].param.value;
  }

  static async getPalette(palette) {
    const palettes = Figures.data.figuredata.colors.palette;
    let index = 0;

    for (index in palettes) {
      if (palettes[index].id != palette) continue;
      break;
    }

    return palettes[index].color;
  }

  static getPaletteColor(palette, id) {
    let index = 0;

    for (index in palette) {
      if (palette[index].id != id) continue;
      break;
    }

    return palette[index];
  }

  static async getAction(id) {
    let index = 0;

    for (index in Figures.actions.actions.action) {
      if (Figures.actions.actions.action[index].id != id) continue;
      break;
    }

    return Figures.actions.actions.action[index];
  }

  static getEffect(id) {
    for (let index in Figures.effects.map.effect) {
      if (Figures.effects.map.effect[index].id != id) continue;
      return Figures.effects.map.effect[index];
    }

    return null;
  }

  static getEffectAsset(manifest, sprite) {
    let result = null;
    const assets = manifest.manifest.manifest.library.assets.asset;

    for (let index in assets) {
      if (assets[index].name != sprite) continue;
      const offsets = assets[index].param.value.split(',');
      result = {
        offset: {
          left: parseInt(offsets[0]),
          top: parseInt(offsets[1])
        }
      };
      break;
    }
    /*if(manifest.manifest.manifest.library.aliases != null) {
        const aliases = manifest.manifest.manifest.library.aliases.alias;
          for(let index in aliases) {
            if(aliases[index].name != sprite)
                continue;
              const alias = Figures.getEffectAsset(manifest, aliases[index].link);
              for(let key in alias) {
                if(result[key] == undefined)
                    result[key] = alias;
            }
              break;
        }
    }*/


    return result;
  }

  static getEffectComposite(ink) {
    switch (ink) {
      case "33":
        return "lighter";
    }

    return "source-over";
  }

  static getEffectIndex(align) {
    switch (align) {
      case "behind":
        return -100;

      case "bottom":
        return -100;

      case "top":
        return 100;
    }

    return 0;
  }

}

_defineProperty(Figures, "logging", {
  missingSprite: false
});

_defineProperty(Figures, "parts", {
  "cc": "ch",
  "lc": "ls",
  "rc": "rs"
});

_defineProperty(Figures, "actionFrames", {
  "Move": 4,
  "Talk": 2,
  "Wave": 1
});

;
Loader.addAsset(async function () {
  Figures.data = await Assets.getManifest("HabboFigureData");
  Figures.map = await Assets.getManifest("HabboFigureMap");
  Figures.actions = await Assets.getManifest("HabboFigureActions");
  Figures.effects = await Assets.getManifest("HabboFigureEffects");
});// @hash v3-B41C50014B3B73BEAA52269798DFF32D3AD1BBFB
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class FigureEntity {
  constructor(figure, properties = {}) {
    _defineProperty(this, "$canvas", $('<canvas width="256" height="256"></canvas>'));

    _defineProperty(this, "events", {
      render: []
    });

    _defineProperty(this, "direction", 2);

    _defineProperty(this, "effect", 0);

    _defineProperty(this, "effectFrame", 0);

    _defineProperty(this, "effectFrames", {});

    _defineProperty(this, "effectDirection", 0);

    _defineProperty(this, "effectRemovals", {});

    _defineProperty(this, "actions", []);

    _defineProperty(this, "actionTimestamp", performance.now());

    _defineProperty(this, "frames", {});

    _defineProperty(this, "data", {});

    this.setFigure(figure);

    for (let key in properties) this[key] = properties[key];
  }

  async getSprite(library, type, id, direction, color) {
    const manifest = await Assets.getManifest("HabboFigures/" + library);
    let frame = 0,
        sprite;
    const partName = Figures.getPartName(type).toLowerCase();

    if (this.effectFrames["bodypart"] != undefined && this.effectFrames["bodypart"][partName] != undefined) {
      const action = await Figures.getAction(this.effectFrames["bodypart"][partName].action);
      sprite = "h_" + action.assetpartdefinition + "_" + type + "_" + id + "_" + direction + "_" + frame;
    }

    if (manifest.sprites[library + "_" + sprite] == undefined) {
      for (let index in this.actions) {
        sprite = "h_" + this.actions[index].assetpartdefinition + "_" + type + "_" + id + "_" + direction + "_" + frame;
        if (manifest.sprites[library + "_" + sprite] == undefined) continue;

        if (this.frames[this.actions[index].id] != undefined) {
          frame = this.frames[this.actions[index].id];
          sprite = "h_" + this.actions[index].assetpartdefinition + "_" + type + "_" + id + "_" + direction + "_" + frame;

          if (manifest.sprites[library + "_" + sprite] == undefined) {
            frame = 0;
            sprite = "h_" + this.actions[index].assetpartdefinition + "_" + type + "_" + id + "_" + direction + "_" + frame;
          }
        }

        break;
      }
    }

    if (manifest.sprites[library + "_" + sprite] == undefined) {
      if (Figures.logging.missingSprite) console.warn("[FigureEntity]%c Unable to locate sprite " + sprite + " in library " + library + "!", "color: lightblue");
      return null;
    }

    let image = await Assets.getSprite("HabboFigures/" + library, library + "_" + sprite);
    if (color != undefined && type != "ey") image = await Assets.getSpriteColor("HabboFigures/" + library, library + "_" + sprite, "#" + color);
    const imageData = await Assets.getSpriteData("HabboFigures/" + library, library + "_" + sprite);
    const spriteData = Figures.getSprite(manifest, sprite).split(',');
    return {
      image,
      imageData,
      left: parseInt(spriteData[0]) * -1,
      top: parseInt(spriteData[1]) * -1
    };
  }

  setFigure(figure) {
    this.parts = {};
    this.figure = figure.split('.');

    for (let index = 0; index < this.figure.length; index++) {
      const parts = this.figure[index].split('-');
      const part = parts[0];
      this.parts[part] = {};
      parts.shift();
      if (parts.length == 0) continue;
      this.parts[part].id = parseInt(parts[0]);
      parts.shift();
      if (parts.length == 0) continue;
      this.parts[part].color = [];

      for (let index in parts) this.parts[part].color[index] = parseInt(parts[index]);
    }
  }

  async setAction(id) {
    if (this.actions.findIndex(x => x.id == id) != -1) return;
    const action = await Figures.getAction(id);
    this.actions.push(action);
    this.actions.sort(function (a, b) {
      return parseInt(a.precedence) - parseInt(b.precedence);
    });
  }

  async setActions(actions) {
    this.actions.length = 0;

    for (let key in actions) await this.setAction(actions[key]);

    await this.setAction("Default");
  }

  updateActions() {
    if (this.actions.length == 0 && this.effect == 0) return false;
    const timestamp = performance.now();
    if (timestamp - this.actionTimestamp < 1000 / 12) return false;
    this.actionTimestamp = timestamp;
    let changed = false;

    if (this.effect != 0) {
      changed = true;
      this.effectFrame++;
    }

    for (let index in this.actions) {
      const id = this.actions[index].id;
      if (Figures.actionFrames[id] == undefined) continue;

      if (this.frames[id] != undefined) {
        this.frames[id]++;
        if (this.frames[id] > Figures.actionFrames[id]) this.frames[id] = 0;
      } else this.frames[id] = 0;

      changed = true;
    }

    return changed;
  }

  removeAction(id) {
    const index = this.actions.findIndex(x => x.id == id);
    if (index == -1) return;
    this.actions.splice(index, 1);
  }

  setEffect(id) {
    this.effect = id;
    this.effectFrame = 0;
    this.effectFrames = {};
    this.effectDirection = 0;
    this.effectRemovals = {};
  }

  async process() {
    await this.setAction("Default");
  }

  async render() {
    const context = this.$canvas[0].getContext("2d");
    context.save();
    const layers = {};
    let direction = this.direction > 3 && this.direction < 7 ? 6 - this.direction : this.direction;
    const sprites = await this.renderEffect(direction);
    let offset = Figures.map.offsets["std"],
        offsetName = "std";
    let priorities = Figures.map.priorities["std"][direction];
    let prioritiesChanged = false,
        offsetChanged = false;

    for (let index in this.actions) {
      const stance = this.actions[index].assetpartdefinition;

      if (prioritiesChanged == false) {
        if (Figures.map.priorities[stance] != undefined) {
          if (Figures.map.priorities[stance][direction] != undefined) {
            priorities = Figures.map.priorities[stance][direction];
            prioritiesChanged = true;
          }
        }
      }

      if (offsetChanged == false) {
        if (Figures.map.offsets[stance] != undefined) {
          offsetName = stance;
          if (Figures.map.offsets[stance].link != undefined) offset = Figures.map.offsets[Figures.map.offsets[stance].link];else offset = Figures.map.offsets[stance];
          offsetChanged = true;
        }
      }
    }

    for (let type in priorities) layers[priorities[type]] = [];

    const shadow = await this.getSprite("hh_human_body", "sd", 1, 0, 0);

    if (shadow != null && this.effectRemovals["bd"] == undefined) {
      shadow.alpha = .25;
      layers["bd"].push(shadow);
    }

    for (let set in this.parts) {
      const setType = await Figures.getSetType(set);
      const setData = await Figures.getSetData(setType, this.parts[set].id);
      let palette = undefined,
          color = undefined;
      if (setData.part.length == undefined) setData.part = [setData.part];

      for (let index in setData.part) {
        const id = parseInt(setData.part[index].id);
        const type = setData.part[index].type;
        if (this.effectRemovals[type] == true) continue;
        let color = undefined;
        const colorIndex = parseInt(setData.part[index].colorindex) - 1;

        if (this.parts[set].color != undefined && this.parts[set].color[colorIndex] != undefined) {
          palette = await Figures.getPalette(setType.paletteid);
          color = Figures.getPaletteColor(palette, this.parts[set].color[colorIndex])["#text"];
        }

        const priorityType = Figures.parts[type] != undefined ? Figures.parts[type] : type;

        if (layers[priorityType] == undefined) {
          console.warn("[FigureEntity]%c Unable to locate type " + type + " in current priority list!", "color: lightblue");
          continue;
        }

        const library = await Figures.getLibrary(id, type);
        const sprite = await this.getSprite(library, type, id, direction, color, priorityType);
        if (sprite == null) continue;
        layers[priorityType].push(sprite);
      }
    }

    context.clearRect(0, 0, 256, 256);

    if (this.direction > 3 && this.direction < 7) {
      context.translate(context.canvas.width, 0);
      context.scale(-1, 1);
    }

    for (let type in layers) {
      for (let index in layers[type]) {
        context.globalAlpha = layers[type][index].alpha == undefined ? 1.0 : layers[type][index].alpha;
        context.drawImage(layers[type][index].image, 128 + offset.left + layers[type][index].left, 128 + offset.top + layers[type][index].top);
      }
    }

    if (this.data[offsetName] == undefined) this.data[offsetName] = {};
    if (this.data[offsetName][this.direction] == undefined) this.data[offsetName][this.direction] = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
    sprites.push({
      image: context.canvas,
      imageData: this.data[offsetName][this.direction],
      left: 0,
      top: 0,
      index: 0
    });
    context.restore();

    if (this.effectFrames["fx"] != undefined) {
      if (this.effectFrames["fx"]["avatar"] != undefined) {
        let left = 0,
            top = 0;
        if (this.effectFrames["fx"]["avatar"].dx != undefined) left = parseInt(this.effectFrames["fx"]["avatar"].dx);
        if (this.effectFrames["fx"]["avatar"].dy != undefined) top = parseInt(this.effectFrames["fx"]["avatar"].dy);

        for (let index in sprites) {
          if (this.effectFrames["fx"][sprites[index].base] != undefined) {
            if (this.effectFrames["fx"][sprites[index].base].dx == undefined) sprites[index].left += left;
            if (this.effectFrames["fx"][sprites[index].base].dy == undefined) sprites[index].top += top;
          } else {
            sprites[index].left += left;
            sprites[index].top += top;
          }
        }
      }
    } //Client.utils.warn("FigureEntity", "Render process took ~" + (Math.round((performance.now() - timestamp) * 100) / 100) + "ms to execute...");
    //timestamp = performance.now();


    for (let event in this.events.render) this.events.render[event](sprites); //Client.utils.warn("FigureEntity", "After math render processes took ~" + (Math.round((performance.now() - timestamp) * 100) / 100) + "ms to execute!");

  }

  async renderEffect(direction) {
    const sprites = [];
    this.effectFrames = {};
    this.effectRemovals = {};
    if (this.effect == 0) return sprites;
    const flipped = this.direction > 3 && this.direction < 7;
    const map = Figures.getEffect(this.effect);
    const manifest = await Assets.getManifest("HabboFigures/" + map.lib);
    if (manifest == undefined || manifest.animation == undefined || manifest.animation.animation == undefined) return sprites;
    if (manifest.animation.animation.direction != undefined) this.effectDirection = parseInt(manifest.animation.animation.direction.offset);else this.effectDirection = 0;

    if (manifest.animation.animation.frame != undefined) {
      if (this.effectFrame >= manifest.animation.animation.frame.length) this.effectFrame = 0;
      const frameFx = manifest.animation.animation.frame[this.effectFrame];

      for (let key in frameFx) {
        this.effectFrames[key] = {};

        for (let index in frameFx[key]) this.effectFrames[key][frameFx[key][index].id] = frameFx[key][index];
      }
    }

    if (manifest.animation.animation.sprite != undefined) {
      if (manifest.animation.animation.sprite.length == undefined) manifest.animation.animation.sprite = [manifest.animation.animation.sprite];

      for (let index in manifest.animation.animation.sprite) {
        if (manifest.animation.animation.sprite[index].id == "avatar") continue;
        let frame = 0,
            left = 0,
            top = 0,
            _direction = direction;

        if (this.effectFrames["fx"] != undefined) {
          if (this.effectFrames["fx"][manifest.animation.animation.sprite[index].id] != undefined) {
            if (this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].frame != undefined) frame = parseInt(this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].frame);
            if (this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dx != undefined) left = parseInt(this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dx);
            if (this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dy != undefined) top = parseInt(this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dy);
            if (this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dd != undefined) _direction = parseInt(this.effectFrames["fx"][manifest.animation.animation.sprite[index].id].dd);
          }
        }

        if (manifest.animation.animation.sprite[index].directions != 1) _direction = 0;
        const name = map.lib + "_h_" + manifest.animation.animation.sprite[index].member + "_" + _direction + "_" + frame;
        const sprite = await Assets.getSprite("HabboFigures/" + map.lib, name, flipped);
        if (sprite == null) continue;
        let directionData = null;

        for (let directionIndex in manifest.animation.animation.sprite[index].direction) {
          if (manifest.animation.animation.sprite[index].direction[directionIndex].id != direction) continue;
          directionData = manifest.animation.animation.sprite[index].direction[directionIndex];
          break;
        }

        if (directionData == null) continue;
        let asset = Figures.getEffectAsset(manifest, "h_" + manifest.animation.animation.sprite[index].member + "_" + _direction + "_" + frame);

        if (asset != null) {
          left += asset.offset.left * -1;
          top += asset.offset.top * -1;
        }

        if (flipped) left += asset.offset.left - sprite.width + 64;
        sprites.push({
          base: manifest.animation.animation.sprite[index].id,
          image: sprite,
          left: left + 96,
          top: top + 170,
          composite: Figures.getEffectComposite(manifest.animation.animation.sprite[index].ink),
          index: directionData.dz != undefined ? parseInt(directionData.dz) : 0
        });
      }
    }

    if (manifest.animation.animation.remove != undefined) {
      if (manifest.animation.animation.remove.length == undefined) manifest.animation.animation.remove = [manifest.animation.animation.remove];

      for (let index in manifest.animation.animation.remove) this.effectRemovals[manifest.animation.animation.remove[index].id] = true;
    }

    if (manifest.animation.animation.add != undefined) {
      if (manifest.animation.animation.add.length == undefined) manifest.animation.animation.add = [manifest.animation.animation.add];

      for (let index in manifest.animation.animation.add) {
        const add = manifest.animation.animation.add[index];
        let frame = 0,
            left = 0,
            top = 0,
            base = add.id;
        if (add.base != undefined) base = add.base;

        if (this.effectFrames["fx"] != undefined) {
          if (this.effectFrames["fx"][base] != undefined) {
            if (this.effectFrames["fx"][base].frame != undefined) frame = parseInt(this.effectFrames["fx"][base].frame);
            if (this.effectFrames["fx"][base].dx != undefined) left = parseInt(this.effectFrames["fx"][base].dx);
            if (this.effectFrames["fx"][base].dy != undefined) top = parseInt(this.effectFrames["fx"][base].dy);
          }
        }

        const name = "h_std_" + base + "_1_" + direction + "_" + frame;
        const sprite = await Assets.getSprite("HabboFigures/" + map.lib, map.lib + "_" + name, flipped);
        if (sprite == null) continue;
        const asset = Figures.getEffectAsset(manifest, name);

        if (asset != null) {
          left += asset.offset.left * -1;
          top += asset.offset.top * -1;
        }

        if (flipped) left += asset.offset.left - sprite.width + 64;
        sprites.push({
          base,
          image: sprite,
          left: left + 96,
          top: top + 170,
          index: Figures.getEffectIndex(add.align)
        });
      }
    }

    return sprites;
  }

}

;// @hash v3-7797381489C77DC43427D48F94412E8D7B20B9F0
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
class FigureRenderer {
  constructor(figure, settings, $canvas, color = undefined) {
    const entity = new FigureEntity(figure, settings);
    entity.events.render.push(function (sprites) {
      const context = $canvas[0].getContext("2d");

      if (color != undefined) {
        context.fillStyle = color;
        context.fillRect(0, 0, context.canvas.width, context.canvas.height);
      }

      for (let index in sprites) {
        context.globalCompositeOperation = sprites[index].composite;
        context.drawImage(sprites[index].image, sprites[index].left, sprites[index].top);
      }
    });
    entity.process().then(function () {
      entity.render();
    });
  }

}

;// @hash v3-0E3B5682E20DF21E413A444040A5B84856C0CB0A
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Badges {
  static async get(id) {
    if (Badges.cache[id] != undefined) return Badges.cache[id];

    if (Badges.promises[id] != undefined) {
      return new Promise(function (resolve) {
        Badges.promises[id].push(function (data) {
          resolve(data);
        });
      });
    }

    Badges.promises[id] = [];
    Badges.cache[id] = await SocketMessages.sendCall({
      OnBadgeRequest: id
    }, "OnBadgeRequest", function (result) {
      if (result.id != id) return 0;
      return 1;
    });

    for (let index in Badges.promises[id]) Badges.promises[id][index](Badges.cache[id]);

    return Badges.cache[id];
  }

}

_defineProperty(Badges, "cache", {});

_defineProperty(Badges, "promises", {});

;// @hash v3-962F0BD259813D1DD4E985E14156E706CD733FAC
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
class BadgeRenderer {
  constructor(id) {
    const $element = $('<div class="badge"></div>');
    const $canvas = $('<img class="badge-image" src="assets/HabboBadges/' + id + '.gif">').appendTo($element);
    Badges.get(id).then(function () {});
    return $element;
  }

}

;// @hash v3-960A8BA6AFE3B4B3128399A11E69C7680CA8100F
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Furnitures {
  static async get(id) {
    if (Furnitures.cache[id] != undefined) return Furnitures.cache[id];

    if (Furnitures.promises[id] != undefined) {
      return new Promise(function (resolve) {
        Furnitures.promises[id].push(function (data) {
          resolve(data);
        });
      });
    }

    Furnitures.promises[id] = [];
    Furnitures.cache[id] = await SocketMessages.sendCall({
      OnFurnitureRequest: id
    }, "OnFurnitureRequest", function (result) {
      if (result.id != id) return 0;
      return 1;
    });

    for (let index in Furnitures.promises[id]) Furnitures.promises[id][index](Furnitures.cache[id]);

    return Furnitures.cache[id];
  }

  getComposite(ink) {
    switch (ink) {
      case "ADD":
        return "lighter";

      case "SUBTRACT":
        return "luminosity";

      case "COPY":
        return "source-over";

      case undefined:
        return "source-over";

      default:
        return ink;
    }
  }

}

_defineProperty(Furnitures, "cache", {
  HabboRoomCursor: {}
});

_defineProperty(Furnitures, "layers", {});

_defineProperty(Furnitures, "promises", {});

;// @hash v3-C01325F330ED61CDDC91A1B6A54D1884707B9EC2
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
const FurnitureFlags = {
  stackable: 1 << 0,
  sitable: 1 << 1,
  standable: 1 << 2,
  walkable: 1 << 3,
  sleepable: 1 << 4
};// @hash v3-D5229F63BBDE49683FE9DAE48B85361757F2B5B5
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class FurnitureEntity {
  constructor(settings = {}) {
    _defineProperty(this, "settings", {
      id: null,
      library: null,
      size: 64,
      direction: null,
      animation: 0
    });

    _defineProperty(this, "events", {
      render: []
    });

    this.update(settings);
  }

  async render() {
    const layerName = this.types.type + "_" + this.settings.size + "_" + this.settings.animation + "_" + this.settings.direction + "_" + JSON.stringify(this.animations);

    if (Furnitures.layers[layerName] == undefined) {
      const layers = this.getLayers();
      const sprites = [];

      for (let index in layers) {
        const layer = layers[index];
        const frame = this.getVisualizationAnimationLayer(index);
        const name = this.getLayerName(this.types.type, this.settings.size, index, this.settings.direction, frame);
        layer.asset = this.getLayerAsset(name);

        if (layer.asset == null) {
          delete layers[index];
          continue;
        }

        layer.sprite = await Assets.getSprite(this.library, layer.asset.name, layer.asset.flipH == 1 ? true : false);

        if (layer.sprite == null) {
          delete layers[index];
          continue;
        }

        layer.spriteData = await Assets.getSpriteData(this.library, layer.asset.name + (layer.asset.flipH == 1 ? "?flipped=true" : ""));
        layer.z = layer.z == undefined ? 0 : parseInt(layer.z);
        layer.ink = layer.ink == undefined ? "source-over" : this.getLayerInk(layer.ink);
        layer.alpha = layer.alpha == undefined ? 1.0 : parseInt(layer.alpha) / 100;
        layer.asset.x = layer.asset.x == undefined ? 0 : parseInt(layer.asset.x);
        layer.asset.y = layer.asset.y == undefined ? 0 : parseInt(layer.asset.y);
        if (layer.asset.flipH == 1) layer.asset.x = layer.asset.x * -1 + layer.sprite.width;
        sprites.push(layer);
      }

      sprites.sort(function (a, b) {
        return a.z - b.z;
      });
      Furnitures.layers[layerName] = sprites;
    }

    for (let index in this.events.render) this.events.render[index](Furnitures.layers[layerName]);
  }

  getLayers() {
    const layerCount = parseInt(this.visualization.layerCount);
    const layers = this.getVisualizationLayers();
    const directions = this.getVisualizationDirectionLayers(this.settings.direction);

    for (let key in directions) {
      if (layers[key] == undefined) layers[key] = {};

      for (let property in directions[key]) layers[property] = directions[key][property];
    }

    for (let index = 0; index < layerCount; index++) {
      if (layers[index] == undefined) layers[index] = {};
    }

    return layers;
  }

  getLayerName(id, size, layer, direction, frame) {
    if (size == 1) return id + "_icon_" + Client.utils.charCode(parseInt(layer));
    return id + "_" + size + "_" + Client.utils.charCode(parseInt(layer)) + "_" + direction + "_" + frame;
  }

  getLayerInk(ink) {
    switch (ink) {
      case "ADD":
        return "lighter";

      case "SUBTRACT":
        return "luminosity";
      //case "COPY": return "source-over";

      default:
        return ink;
    }
  }

  getLayerAsset(name) {
    for (let index in this.manifest.assets.assets.asset) {
      const asset = JSON.parse(JSON.stringify(this.manifest.assets.assets.asset[index]));
      if (asset.name != name) continue;

      if (asset.source != undefined && asset.source != asset.name) {
        const sourceAsset = this.getLayerAsset(asset.source);
        delete asset.source;

        for (let key in sourceAsset) {
          if (asset[key] == undefined) asset[key] = sourceAsset[key];
        }

        asset.name = sourceAsset.name;
      }

      return asset;
    }

    return null;
  }

  getVisualization() {
    const data = this.manifest.visualization.visualizationData;
    const visualization = data.graphics != undefined ? data.graphics.visualization : data.visualization;

    for (let index in visualization) {
      if (visualization[index].size == this.settings.size) return visualization[index];
    }

    return null;
  }

  getVisualizationLayers() {
    const layers = {};
    if (this.visualization.layers == undefined) return {};
    if (this.visualization.layers.layer.length == undefined) this.visualization.layers.layer = [this.visualization.layers.layer];

    for (let index in this.visualization.layers.layer) {
      const layer = this.visualization.layers.layer[index];
      layers[layer.id] = {};

      for (let key in layer) {
        if (key == "id") continue;
        layers[layer.id][key] = layer[key];
      }
    }

    return layers;
  }

  getVisualizationDirectionLayers() {
    if (this.visualization.directions == undefined) return {};
    if (this.visualization.directions.direction.length == undefined) this.visualization.directions.direction = [this.visualization.directions.direction];

    for (let index in this.visualization.directions.direction) {
      if (this.visualization.directions.direction[index].id != this.settings.direction) continue;
      const directions = this.visualization.directions.direction[index];
      if (directions.layer == undefined) return {};
      if (directions.layer.length == undefined) directions.layer = [directions.layer];
      const layers = {};

      for (let index in directions.layer) {
        const layer = directions.layer[index];
        layers[layer.id] = {};

        for (let key in layer) {
          if (key == "id") continue;
          layers[layer.id][key] = layer[key];
        }
      }

      return layers;
    }

    return {};
  }

  getVisualizationAnimation() {
    if (this.visualization.animations == null || this.visualization.animations == undefined) return undefined;

    if (this.settings.animation != 0) {
      if (this.types.logic == "furniture_score") {
        const layers = {};
        let layer = 2;

        for (let index = 1; index <= 100; index *= 10) {
          layers["" + layer] = {
            frameSequence: [Math.floor(this.settings.animation / index % 10)],
            frameRepeat: 0,
            frameRepeatSequence: 0,
            frameLoop: 0,
            frameTransition: undefined,
            frame: 0
          };
          layer++;
        }

        return layers;
      } else if (this.types.logic == "furniture_counter_clock") {
        const layers = {};
        const minutes = Math.floor(this.settings.animation / 60);
        const seconds = this.settings.animation - minutes * 60;
        layers["" + 6] = {
          frameSequence: [Math.floor(seconds / 1 % 10)],
          frameRepeat: 0,
          frameRepeatSequence: 0,
          frameLoop: 0,
          frameTransition: undefined,
          frame: 0
        };
        layers["" + 7] = {
          frameSequence: [Math.floor(seconds / 10 % 10)],
          frameRepeat: 0,
          frameRepeatSequence: 0,
          frameLoop: 0,
          frameTransition: undefined,
          frame: 0
        };
        layers["" + 8] = {
          frameSequence: [Math.floor(minutes / 1 % 10)],
          frameRepeat: 0,
          frameRepeatSequence: 0,
          frameLoop: 0,
          frameTransition: undefined,
          frame: 0
        };
        layers["" + 9] = {
          frameSequence: [Math.floor(minutes / 10 % 10)],
          frameRepeat: 0,
          frameRepeatSequence: 0,
          frameLoop: 0,
          frameTransition: undefined,
          frame: 0
        };
        return layers;
      }
    }

    for (let index in this.visualization.animations.animation) {
      if (this.visualization.animations.animation[index].id != this.settings.animation) continue;
      const animationProperties = this.visualization.animations.animation[index];
      let animationLayers = this.visualization.animations.animation[index].animationLayer;
      if (animationLayers == undefined) return undefined;
      if (animationLayers.length == undefined) animationLayers = [animationLayers];
      const layers = {};
      let layerCount = 0;

      for (let index in animationLayers) {
        const layer = animationLayers[index].id;
        if (animationLayers[index].frameSequence == undefined) continue;
        if (animationLayers[index].frameSequence.frame == undefined) continue;
        layers[layer] = {
          frameSequence: [],
          frameRepeat: animationLayers[index].frameRepeat != undefined ? parseInt(animationLayers[index].frameRepeat) : 0,
          frameRepeatSequence: 0,
          frameLoop: animationLayers[index].loopCount != undefined ? parseInt(animationLayers[index].loopCount) : 0,
          frameTransition: animationProperties.transitionTo != undefined ? parseInt(animationProperties.transitionTo) : undefined,
          frame: 0
        };
        if (animationLayers[index].frameSequence.frame.length == undefined) animationLayers[index].frameSequence.frame = [animationLayers[index].frameSequence.frame];

        for (let frame in animationLayers[index].frameSequence.frame) layers[layer].frameSequence.push(animationLayers[index].frameSequence.frame[frame].id);

        layerCount++;
      }

      if (layerCount == 0) return undefined;
      return layers;
    }

    if (this.settings.animation >= 100) {
      this.settings.animation -= 100;
      this.animations = this.getVisualizationAnimation();
      return this.animations;
    }

    return undefined;
  }

  getVisualizationAnimationLayer(layer) {
    if (this.animations == undefined || this.animations[layer] == undefined) return 0;
    return this.animations[layer].frameSequence[this.animations[layer].frame];
  }

  getDimensions() {
    const result = {
      row: 0,
      column: 0,
      depth: 0
    };
    const data = this.manifest.logic.objectData.model.dimensions;
    if (data.x != undefined) result.row = parseFloat(data.x);
    if (data.y != undefined) result.column = parseFloat(data.y);
    if (data.z != undefined) result.depth = parseFloat(data.z);

    if (this.settings.direction == 0 || this.settings.direction == 4) {
      const spare = result.row;
      result.row = result.column;
      result.column = spare;
    }

    return result;
  }

  getDirection(direction = this.settings.direction) {
    const directions = this.manifest.logic.objectData.model.directions;
    if (directions == undefined) return 0;
    if (directions.direction.length == undefined) directions.direction = [directions.direction];

    for (let index in directions.direction) {
      if (this.getDirectionAngle(directions.direction[index].id) != direction) continue;
      return direction;
    }

    return this.getDirectionAngle(directions.direction[0].id);
  }

  getNextDirection(direction = this.settings.direction) {
    const directions = this.manifest.logic.objectData.model.directions;
    if (directions == undefined) return direction;
    if (directions.direction.length == undefined) directions.direction = [directions.direction];

    for (let index in directions.direction) {
      if (this.getDirectionAngle(directions.direction[index].id) != direction) continue;
      if (directions.direction[parseInt(index) + 1] == undefined) return this.getDirectionAngle(directions.direction[0].id);
      return this.getDirectionAngle(directions.direction[parseInt(index) + 1].id);
    }

    return this.getDirectionAngle(directions.direction[0].id);
  }

  getDirectionAngle(angle) {
    return Math.floor(parseInt(angle) / 45);
  }

  async update(settings) {
    if (settings.id != undefined && settings.id == "HabboRoomCursor") settings.library = settings.id;

    for (let key in settings) this.settings[key] = settings[key];
  }

  getNextAnimation(animation = this.settings.animation) {
    const animations = this.visualization.animations;
    if (animations == undefined) return 0;
    if (animations.animation.length == undefined) animations.animation = [animations.animation];

    for (let index in animations.animation) {
      if (animations.animation[index].id != animation) continue;
      if (animations.animation[parseInt(index) + 1] == undefined) return parseInt(animations.animation[0].id);
      return parseInt(animations.animation[parseInt(index) + 1].id);
    }

    return parseInt(animations.animation[0].id);
  }

  updateAnimations(timestamp = performance.now()) {
    let updated = false;
    if (this.animations == undefined) return false;

    for (let index in this.animations) {
      if (!(timestamp - this.animationTimestamps[index] > 1000 / 12)) continue;

      if (this.animations[index].frameRepeatSequence != this.animations[index].frameRepeat) {
        this.animations[index].frameRepeatSequence++;
        continue;
      }

      this.animations[index].frameRepeatSequence = 0;
      const previousFrame = this.animations[index].frame;
      this.animations[index].frame++;

      if (this.animations[index].frame >= this.animations[index].frameSequence.length) {
        this.animations[index].frame = 0;

        if (this.animations[index].frameTransition != undefined) {
          this.setAnimation(this.animations[index].frameTransition);
          return true;
        }
      }

      this.animationTimestamps[index] = timestamp;
      if (this.animations[index].frameSequence[previousFrame] != this.animations[index].frameSequence[this.animations[index].frame]) updated = true;
    }

    return updated;
  }

  setAnimation(animation) {
    this.settings.animation = animation;

    if (this.types.logic == "furniture_score") {}

    this.animations = this.getVisualizationAnimation();
    this.animationTimestamps = {};

    for (let index in this.animations) this.animationTimestamps[index] = 0;

    this.render();
  }

  setDirection(direction) {
    this.settings.direction = this.getDirection(direction);
  }

  async process() {
    this.furniture = await Furnitures.get(this.settings.id);
    this.library = this.settings.library != null ? this.settings.library : "HabboFurnitures/" + this.furniture.line + "/" + this.furniture.id;
    this.manifest = await Assets.getManifest(this.library);
    this.visualization = this.getVisualization();
    this.types = this.manifest.index.object;
    if (this.settings.animation != undefined) this.setAnimation(this.settings.animation);
    this.settings.direction = this.getDirection();
  }

}

;// @hash v3-672BAA93B0D974B9E5F3F1CB389EC20853FE7FBB
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
class FurnitureRenderer {
  constructor(settings, $canvas, color = undefined) {
    this.settings = settings;
    this.$canvas = $canvas;
    this.color = color;
    this.renderer();
  }

  async renderer() {
    const loading = await Assets.getSpritesheet(this.settings.size == 1 ? "HabboLoadingIcon" : "HabboLoading").then(function (image) {
      const context = this.$canvas[0].getContext("2d");
      context.canvas.width = image.width;
      context.canvas.height = image.height;
      context.drawImage(image, 0, 0);
    });
    const entity = new FurnitureEntity(this.settings);
    entity.events.render.push(function (sprites) {
      const context = this.$canvas[0].getContext("2d");
      let minLeft = 0,
          minTop = 0,
          maxWidth = 0,
          maxHeight = 0;

      for (let index in sprites) {
        if (minLeft > sprites[index].asset.x * -1) minLeft = sprites[index].asset.x * -1;
        if (minTop > sprites[index].asset.y * -1) minTop = sprites[index].asset.y * -1;
        if (sprites[index].asset.x * -1 + sprites[index].sprite.width > maxWidth) maxWidth = sprites[index].asset.x * -1 + sprites[index].sprite.width;
        if (sprites[index].asset.y * -1 + sprites[index].sprite.height > maxHeight) maxHeight = sprites[index].asset.y * -1 + sprites[index].sprite.height;
      }

      context.canvas.width = minLeft * -1 + maxWidth;
      context.canvas.height = minTop * -1 + maxHeight;

      if (this.color != undefined) {
        context.fillStyle = this.color;
        context.fillRect(0, 0, context.canvas.width, context.canvas.height);
      }

      for (let index in sprites) {
        context.globalCompositeOperation = sprites[index].ink;
        context.drawImage(sprites[index].sprite, minLeft * -1 - sprites[index].asset.x, minTop * -1 - sprites[index].asset.y);
      }
    });
    entity.process().then(async () => {
      await entity.render();

      if (entity.types.visualization == "furniture_animated") {
        setInterval(() => {
          const timestamp = performance.now();
          if (!entity.updateAnimations(timestamp)) return;
          entity.render();
        }, 1000 / 12);
        this.$canvas.on("click", function () {
          entity.setAnimation(entity.getNextAnimation());
        });
      }
    });
  }

}

;// @hash v3-D517CE2F71839339BFAC70C6CB99AB74329B14F7
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Canvas {
  static addCanvas(canvas, settings) {
    const properties = {
      canvas,
      offset: {
        left: 0,
        top: 0
      },
      draggable: true,
      draggableEnabled: false,
      draggableRate: 0,
      draggableTimestamp: 0,
      frame: 0,
      frameRate: 24,
      frameStamp: performance.now(),
      frameLogs: [],
      enabled: true
    };

    for (let key in settings) properties[key] = settings[key];

    if (properties.draggable) {
      let position = null;
      $(properties.canvas).on("mousedown", function (event) {
        if (Keys.down["ShiftLeft"]) return;
        properties.draggableEnabled = true;
        properties.draggableTimestamp = performance.now();
        position = {
          left: event.offsetX,
          top: event.offsetY
        };
      }).on("mouseup", function () {
        properties.draggableEnabled = false;
      }).on("mousemove", function (event) {
        if (properties.draggableEnabled == false) return;
        properties.offset.left += event.offsetX - position.left;
        properties.offset.top += event.offsetY - position.top;
        position = {
          left: event.offsetX,
          top: event.offsetY
        };
      });
    }

    properties.start = function () {
      properties.enabled = true;
    };

    properties.destroy = function () {
      properties.enabled = false;
    };

    properties.stop = function () {
      properties.enabled = false;
    };

    Canvas.list.push(properties);
    return properties;
  }

  static render() {
    const timestamp = performance.now();

    for (let index in Canvas.list) {
      if (Canvas.list[index].enabled == false) continue;
      if (Canvas.list[index].render == undefined) continue;

      if (Canvas.list[index].draggableEnabled == false && Canvas.list[index].frameRate != 0 || Canvas.list[index].draggableEnabled == true && Canvas.list[index].draggableRate != 0) {
        const delta = timestamp - Canvas.list[index].frameStamp;
        const interval = 1000 / Canvas.list[index].frameRate;
        if (delta < interval) continue;
        Canvas.list[index].frameStamp = timestamp - delta % interval;
      }

      Canvas.list[index].frame++;
      if (Canvas.list[index].frame == Canvas.list[index].frameRate + 1) Canvas.list[index].frame = 1;

      for (let log in Canvas.list[index].frameLogs) if (timestamp - Canvas.list[index].frameLogs[log] >= 1000) Canvas.list[index].frameLogs.splice(log, 1);

      Canvas.list[index].frameLogs.push(timestamp);
      Canvas.list[index].render(Canvas.list[index]);
      const context = Canvas.list[index].canvas.getContext("2d");
      context.resetTransform();
      context.font = "13px Ubuntu Regular";
      context.fillStyle = "rgba(255, 255, 255, .5)";
      context.textAlign = "right";
      context.fillText(Canvas.list[index].frameLogs.length + " FPS", context.canvas.width - 12, context.canvas.height - 12);
    }

    window.requestAnimationFrame(function () {
      Canvas.render();
    });
  }

}

_defineProperty(Canvas, "list", []);

;
window.requestAnimationFrame(function () {
  Canvas.render();
});// @hash v3-771610C9461F4B92C0490175EEC5114C2C529404
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.rooms = new function () {
  this.items = new function () {}();
}();// @hash v3-1F08254129F8B3C43270746159047C3D8D2B55AD
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomEntity = function ($parent) {
  this.background = "#111";
  this.offset = [0, 0];
  this.center = 0;

  this.setOffset = function (left, top) {
    this.offset = [left, top];
  };

  this.entities = [];

  this.addEntity = function (entity) {
    this.entities.push(entity);
    return entity;
  };

  this.currentEntity = undefined;

  this.getEntity = function (position, type = null) {
    if (position == undefined) return undefined;
    const offset = [position[0] - this.offset[0] - this.center, position[1] - this.offset[1]];
    const sprites = type == null ? this.sprites : this.sprites.filter(x => x.parent.name == type);

    for (let index = sprites.length - 1; index != -1; index--) {
      const mouseover = sprites[index].mouseover(offset, this.center);
      if (mouseover == false) continue;
      return {
        entity: sprites[index].parent,
        sprite: sprites[index],
        result: mouseover
      };
    }

    return undefined;
  };

  this.removeEntity = function (entity) {
    const index = this.entities.indexOf(entity);
    if (index == -1) return;
    this.entities.splice(index, 1);
  };

  this.$canvas = $('<canvas></canvas>').appendTo($parent);

  this.updateCanvas = function () {
    const width = $parent.width();
    const height = $parent.height();
    this.$canvas.attr({
      "width": width,
      "height": height
    });
    /*.css({
        "width": Math.floor(width * window.devicePixelRatio),
        "height": Math.floor(height * window.devicePixelRatio)
    })*/
  };

  this.sprites = [];
  this.frame = 0;
  this.frameRate = 24;
  this.frameRates = [];
  this.frameStamp = performance.now();
  this.framePerformance = [];

  this.render = function () {
    let timestamp = performance.now();

    if (timestamp - this.frameStamp > 1000 / this.frameRate) {
      this.frame++;
      if (this.frame > this.frameRate) this.frame = 0;
      this.frameStamp = timestamp;
    }

    for (let index = 0; index < this.entities.length; index++) this.entities[index].process(timestamp, this.frame);

    this.updateCanvas();

    for (let index = 0; index < this.events.beforeRender.length; index++) this.events.beforeRender[index]();

    const context = this.$canvas[0].getContext("2d");
    context.fillStyle = this.background;
    context.fillRect(0, 0, context.canvas.width, context.canvas.height);
    context.save(); //context.imageSmoothingEnabled = false;
    //context.scale(window.devicePixelRatio, window.devicePixelRatio);

    this.sprites = [];

    for (let index = 0; index < this.entities.length; index++) {
      if (this.entities[index].enabled == false) continue;
      this.sprites = this.sprites.concat(this.entities[index].sprites);
    }

    this.sprites.sort(function (a, b) {
      return a.getIndex() - b.getIndex();
    });
    const offset = [this.center + this.offset[0], this.offset[1]];

    for (let index = 0; index < this.sprites.length; index++) this.sprites[index].render(context, offset);

    for (let index = 0; index < this.events.render.length; index++) this.events.render[index]();

    context.restore();
    if (this.framePerformance.length == this.frameRate) this.framePerformance.shift();
    const milliseconds = Math.round((performance.now() - timestamp) * 100) / 100;
    this.framePerformance.push(milliseconds);
    const median = Client.utils.getArrayMedian(this.framePerformance);

    if (median > 6) {//console.warn("[RoomEntity]%c Execution for last " + this.framePerformance.length + " frames took ~" + (Math.round(median * 100) / 100) + "ms; last took ~" + milliseconds + "ms!", "color: lightblue");
      //this.framePerformance.length = 0;
    }

    timestamp = performance.now();

    for (let index in this.frameRates) {
      if (timestamp - this.frameRates[index] >= 1000) {
        this.frameRates.splice(index, 1);
      }
    }

    this.frameRates.push(timestamp);
    Client.development.$frames.text(this.frameRates.length + " FPS");
    return {
      median,
      milliseconds,
      frames: this.frameRates.length
    };
  };

  this.events = new function () {
    this.render = [];
    this.beforeRender = [];
  }();

  this.setCursor = function (cursor) {
    this.$canvas.css("cursor", cursor);
  };
};// @hash v3-5080A71EBA195BD3C0F0376D425C730178968BB2
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomCategories = new function () {
  this.get = async function () {
    if (this.categories != undefined) return this.categories;
    this.categories = await SocketMessages.sendCall({
      OnRoomCategoriesUpdate: null
    }, "OnRoomCategoriesUpdate");
    return this.categories;
  };
}();// @hash v3-53C0AEA86B4D7D4CDBE297E9B90B74D5A44F9988
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.rooms.map = new function () {
  this.getIndex = function (data, id) {
    const array = Client.rooms.asset.room_visualization.visualizationData[data + "Data"][data + "s"][data];
    let index = 0;

    for (index in array) {
      if (array[index].id != id) continue;
      break;
    }

    return index;
  };

  this.getSizes = function (data, index) {
    const array = Client.rooms.asset.room_visualization.visualizationData[data + "Data"][data + "s"][data];
    return array[index].visualization;
  };

  this.getVisualization = function (data, size) {
    let index = 0;

    for (index in data) {
      if (data[index].size != size) continue;
      break;
    }

    return data[index].visualizationLayer;
  };

  this.getMaterial = function (data, material) {
    const materials = Client.rooms.asset.room_visualization.visualizationData[data + "Data"].materials.material;
    let index = 0;

    for (index in materials) {
      if (materials[index].id != material) continue;
      break;
    }

    return materials[index].materialCellMatrix.materialCellColumn;
  };

  this.getTexture = function (data, texture) {
    const textures = Client.rooms.asset.room_visualization.visualizationData[data + "Data"].textures.texture;
    let index = 0;

    for (index in textures) {
      if (textures[index].id != texture) continue;
      break;
    }

    return "HabboRoomContent_" + textures[index].bitmap.assetName;
  };

  this.getAsset = function (name) {
    const assets = Client.rooms.asset.room_assets.assets.asset;
    let index = 0;

    for (index in assets) {
      if (assets[index].name == name) break;
    }

    const asset = JSON.parse(JSON.stringify(assets[index]));

    if (asset.source != undefined) {
      const source = this.getAsset(asset.source);

      for (let key in source) if (asset[key] == undefined) asset[key] = source[key];
    }

    return asset;
  };

  this.getMask = function (name) {
    const asset = this.getAsset(name);
    return {
      asset
    };
  };
}();// @hash v3-E90A2BF096CF68070264FE65B4D2A9A8D7A781DD
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.rooms.map.entity = function (map, door = {}, floor = {}, wall = {}) {
  this.settings = {
    map: map,
    door: {
      row: null,
      column: null
    },
    floor: {
      material: "default",
      thickness: 8
    },
    wall: {
      material: "default",
      thickness: 8
    }
  };

  this.render = async function () {
    this.rows = this.settings.map.length;
    this.columns = 0;
    this.depth = 0;

    for (let row in this.settings.map) if (this.settings.map[row].length > this.columns) this.columns = this.settings.map[row].length;

    this.map = {};

    for (let row in this.settings.map) {
      this.map[row] = {};

      for (let column in this.settings.map[row]) {
        this.map[row][column] = this.settings.map[row][column];
        if (this.map[row][column] == 'X') continue;
        if (!Client.utils.isLetter(this.map[row][column])) this.map[row][column] = parseInt(this.map[row][column]);else this.map[row][column] = Client.utils.fromCharCode(this.map[row][column]);
        if (this.map[row][column] > this.depth) this.depth = this.map[row][column];
      }
    }

    if (this.getCoordinate(door.row + 1, door.column) == 'X' && this.getCoordinate(door.row - 1, door.column) == 'X') this.settings.door = door;
    await this.renderFloor();
    await this.renderWall();
  };

  this.renderPatterns = async function (type, id) {
    const index = Client.rooms.map.getIndex(type, id);
    const sizes = Client.rooms.map.getSizes(type, index);
    const visualization = Client.rooms.map.getVisualization(sizes, 64);
    const material = Client.rooms.map.getMaterial(type, visualization.materialId);
    const texture = Client.rooms.map.getTexture(type, material.materialCell.textureId);
    let canvas,
        context,
        patterns = [];
    canvas = await Assets.getSpriteColor("HabboRoomContent", texture, visualization.color);
    context = canvas.getContext("2d");
    patterns[0] = context.createPattern(canvas, "repeat");
    canvas = await Assets.getSpriteColor("HabboRoomContent", texture + "?color=" + visualization.color, "#666");
    context = canvas.getContext("2d");
    patterns[1] = context.createPattern(canvas, "repeat");
    canvas = await Assets.getSpriteColor("HabboRoomContent", texture + "?color=" + visualization.color, "#BBB");
    context = canvas.getContext("2d");
    patterns[2] = context.createPattern(canvas, "repeat");
    return patterns;
  };

  this.renderFloor = async function () {
    const patterns = await this.renderPatterns("floor", this.settings.floor.material); // TODO: check if the +10 is actually needed

    const width = this.rows * 32 + this.columns * 32;
    const height = this.rows * 16 + this.columns * 16 + this.settings.floor.thickness + this.depth * 16 + 10;
    this.floor = [];
    this.$floor = $('<canvas width="' + width + '" height="' + height + '"></canvas>');
    const allRectangles = [];

    for (let row in this.map) {
      for (let column in this.map[row]) {
        const tile = this.getCoordinate(row, column, true);
        if (tile == 'X') continue;

        if (this.getCoordinate(row, parseInt(column) - 1) == tile + 1) {
          for (let step = 0; step < 4; step++) {
            allRectangles.push({
              row,
              column: parseInt(column) + step * .25,
              depth: tile + 0.75 - step * .25,
              width: 8,
              height: 32
            });
          }

          continue;
        }

        if (this.getCoordinate(parseInt(row) - 1, column) == tile + 1) {
          for (let step = 0; step < 4; step++) {
            allRectangles.push({
              row: parseInt(row) + step * .25,
              column,
              depth: tile + 0.75 - step * .25,
              width: 32,
              height: 8
            });
          }

          continue;
        }

        allRectangles.push({
          row,
          column,
          depth: tile,
          width: 32,
          height: 32
        });
      }
    }

    const context = this.$floor[0].getContext("2d");

    for (let _depth = 0; _depth <= this.depth; _depth++) {
      const rectangles = allRectangles.filter(x => Math.ceil(x.depth) == _depth);
      if (rectangles.length == 0) continue;
      context.beginPath();
      context.setTransform(1, .5, 0, 1, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
      context.fillStyle = patterns[2];

      for (let index in rectangles) {
        const rectangle = rectangles[index];
        if (rectangles.find(x => parseInt(x.row) == parseInt(rectangle.row) + 1 && x.column == rectangle.column && x.depth == rectangle.depth) != null) continue;
        const left = rectangle.column * 32 - rectangle.row * 32 - rectangle.height;
        const top = rectangle.row * 32 - rectangle.depth * 32 + rectangle.height;
        context.rect(left, top, rectangle.width, this.settings.floor.thickness);
      }

      context.fill();
      context.beginPath();
      context.setTransform(1, -.5, 0, 1, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
      context.fillStyle = patterns[1];

      for (let index in rectangles) {
        const rectangle = rectangles[index];
        if (rectangles.find(x => x.row == rectangle.row && parseInt(x.column) == parseInt(rectangle.column) + 1 && x.depth == rectangle.depth) != null) continue;
        const row = parseFloat(rectangle.row);
        const column = parseFloat(rectangle.column);
        const left = -(row * 32) + column * 32 + rectangle.width - rectangle.height;
        const top = column * 32 - rectangle.depth * 32 + rectangle.width;
        context.rect(left, top, rectangle.height, this.settings.floor.thickness);
      }

      context.fill();
      context.beginPath();
      context.setTransform(1, .5, -1, .5, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
      context.fillStyle = patterns[0];
      const tiles = new Path2D();

      for (let index in rectangles) {
        const rectangle = rectangles[index];
        const left = rectangle.column * 32 - rectangle.depth * 32;
        const top = rectangle.row * 32 - rectangle.depth * 32;
        const path = new Path2D();
        path.rect(left, top, rectangle.width, rectangle.height);
        this.floor.push({
          row: rectangle.row,
          column: rectangle.column,
          depth: rectangle.depth,
          path
        });
        tiles.addPath(path);
      }

      context.fill(tiles);
    }
  };

  this.renderWall = async function () {
    const patterns = await this.renderPatterns("wall", this.settings.wall.material);
    const context = this.$wall[0].getContext("2d");
    context.canvas.width = this.rows * 32 + this.columns * 32 + 2 * this.settings.floor.thickness;
    context.canvas.height = this.rows * 32 + this.columns * 16 + this.depth * 16 + this.settings.floor.thickness;
    const rectangles = [];

    for (let row in this.map) {
      for (let column in this.map[row]) {
        const depth = this.getCoordinate(row, column, true);
        if (depth == 'X') continue;
        if (this.settings.door.row == row && this.settings.door.column == column) continue;
        let hasPrevious = false;

        for (let previousRow = row - 1; previousRow >= 0; previousRow--) {
          if (this.getCoordinate(previousRow, column, true) == 'X') {
            for (let previousColumn = column - 1; previousColumn >= 0; previousColumn--) {
              if (this.getCoordinate(previousRow, previousColumn, true) == 'X') continue;
              hasPrevious = true;
              break;
            }

            if (hasPrevious) break;
            continue;
          }

          hasPrevious = true;
          break;
        }

        if (hasPrevious) continue;
        rectangles.push({
          row: parseInt(row),
          column: parseInt(column),
          depth,
          direction: 4
        });
      }
    }

    for (let row in this.map) {
      for (let column in this.map[row]) {
        const depth = this.getCoordinate(row, column, true);
        if (depth == 'X') continue;
        let hasPrevious = false;

        for (let previousColumn = column - 1; previousColumn >= 0; previousColumn--) {
          if (this.getCoordinate(row, previousColumn, true) != 'X') {
            hasPrevious = true;
            break;
          }

          for (let previousRow = row - 1; previousRow >= 0; previousRow--) {
            if (this.getCoordinate(previousRow, previousColumn, true) != 'X') {
              hasPrevious = true;
              break;
            }
          }
        }

        if (hasPrevious) continue;
        rectangles.push({
          row: parseInt(row),
          column: parseInt(column),
          depth,
          direction: 2
        });
      }
    }

    const rectanglesLeft = rectangles.filter(x => x.direction == 4);

    for (let index in rectanglesLeft) {
      const rectangle = rectanglesLeft[index];
      if (rectangles.find(x => x.direction == 2 && x.row == rectangle.row && x.column == rectangle.column) == null) continue;
      rectangles.push({
        row: rectangle.row,
        column: rectangle.column,
        depth: rectangle.depth,
        direction: 1
      });
    }

    this.offset = -((this.depth + 3.5) * 32);
    context.beginPath();
    context.setTransform(1, -.5, 0, 1, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
    context.fillStyle = patterns[1];

    for (let index in rectangles) {
      const rectangle = rectangles[index];
      let width = 32;
      let height = (3.5 + (this.depth - rectangle.depth)) * 32;
      let row = rectangle.row;
      let column = rectangle.column;

      if (rectangle.direction == 4) {
        column++;
        if (this.getCoordinate(row, column) != 'X') continue;
        width = this.settings.wall.thickness;
        height += this.settings.floor.thickness;
      } else if (rectangle.direction == 2) {
        row++;
      } else continue;

      const left = -(row * 32) + column * 32;
      const top = column * 32 - this.depth * 16;
      context.rect(left, top, width, height);
    }

    context.fill();
    context.closePath();
    context.beginPath();
    context.setTransform(1, .5, 0, 1, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
    context.fillStyle = patterns[2];

    for (let index in rectangles) {
      const rectangle = rectangles[index];
      let row = rectangle.row;
      let column = rectangle.column;
      let width = 32;
      let height = (3.5 + (this.depth - rectangle.depth)) * 32;

      if (rectangle.direction == 4) {} else if (rectangle.direction == 2) {
        row++;
        if (this.getCoordinate(row, column) != 'X') continue;
        width = this.settings.wall.thickness;
        height += this.settings.floor.thickness;
      } else continue;

      let left = column * 32 - row * 32;
      let top = row * 32 - this.depth * 16;
      context.rect(left - (width == 32 ? 0 : this.settings.wall.thickness), top, width, height);
    }

    context.fill();
    context.closePath();
    context.beginPath();
    context.setTransform(1, .5, -1, .5, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
    context.fillStyle = patterns[0];

    for (let index in rectangles) {
      const rectangle = rectangles[index];
      let row = rectangle.row;
      let column = rectangle.column;
      let width = 32;
      let height = 32;
      let left = column * 32 - this.depth * 16;
      let top = row * 32 - this.depth * 16;

      if (rectangle.direction == 1) {
        width = this.settings.wall.thickness;
        height = this.settings.wall.thickness;
        left -= this.settings.wall.thickness;
        top -= this.settings.wall.thickness;
      } else if (rectangle.direction == 2) {
        width = this.settings.wall.thickness;
        left -= this.settings.wall.thickness;
      } else if (rectangle.direction == 4) {
        height = this.settings.wall.thickness;
        top -= this.settings.wall.thickness;
      } else continue;

      context.rect(left, top, width, height);
    }

    context.fill();
    context.closePath();

    if (this.settings.door.row != null && this.settings.door.column != null) {
      const mask = Client.rooms.map.getMask("door_64");
      const sprite = await Assets.getSprite("HabboRoomContent", "HabboRoomContent_" + mask.asset.name);
      context.globalCompositeOperation = "destination-out";
      context.setTransform(1, -.5, 0, 1, this.settings.wall.thickness + this.rows * 32, this.depth * 16);
      const row = this.settings.door.row;
      const column = this.settings.door.column;
      const depth = this.getCoordinate(row, column);
      const left = -(row * 32) + column * 32;
      const top = this.settings.wall.thickness / 2 + column * 32 - this.depth * 16 + (3.5 + (this.depth - depth)) * 32 + 32 - sprite.height;
      context.drawImage(sprite, left, top);
    }
  };

  this.getCoordinate = function (row, column, door = false) {
    if (door && this.settings.door.row == row && this.settings.door.column == column) {
      if (this.getCoordinate(row + 1, column) == 'X') return 'X';
    }

    if (this.map[row] == undefined || this.map[row][column] == undefined) return 'X';
    return this.map[row][column];
  };

  for (let key in floor) this.settings.floor[key] = floor[key];

  for (let key in wall) this.settings.wall[key] = wall[key];

  this.$wall = $('<canvas></canvas>');
};// @hash v3-09046FA7D571DD6985A82E415BF6382035346C28
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.entity = function (parent, name) {
  this.events = new function () {
    this.path = {
      start: [],
      frame: [],
      finish: []
    };
  }();
  this.parent = parent;
  this.name = name;
  this.index = 0;
  this.alpha = 1.0;
  this.sprites = [];
  this.data = {};
  this.offset = [0, 0];

  this.getOffset = function () {
    return [this.offset[0], this.offset[1]];
  };

  this.path = false;

  this.setPath = function (from, to, ticks = 500) {
    this.path = true;
    this.pathFrame = 0;
    this.pathFrames = Math.floor(24 / 1000 * ticks);
    this.pathLastFrame = -1;
    this.pathTick = performance.now();
    this.pathTicks = ticks;
    this.pathFrom = from;
    this.pathTo = to;
    this.pathDifference = {
      row: to.row - from.row,
      column: to.column - from.column,
      depth: to.depth - from.depth
    };

    for (let index in this.events.path.start) this.events.path.start[index]();
  };

  this.stopPath = function (finish = true) {
    if (this.path == false) return;
    this.path = false;
    if (finish) this.setCoordinates(this.pathTo.row, this.pathTo.column, this.pathTo.depth);

    for (let index in this.events.path.finish) this.events.path.finish[index]();
  };

  this.updatePath = function (frame) {
    if (!this.path) return;
    const timestamp = performance.now();
    const tick = timestamp - this.pathTick;

    if (tick > this.pathTicks) {
      this.path = false;
      this.setCoordinates(this.pathTo.row, this.pathTo.column, this.pathTo.depth);

      for (let index in this.events.path.finish) this.events.path.finish[index]();

      return;
    }

    this.setCoordinates(this.pathFrom.row + this.pathDifference.row / this.pathTicks * tick, this.pathFrom.column + this.pathDifference.column / this.pathTicks * tick, this.pathFrom.depth + this.pathDifference.depth / this.pathTicks * tick);

    if (frame != this.pathLastFrame) {
      this.pathLastFrame = frame;
      this.pathFrame++;
      if (this.pathFrame == this.pathFrames) this.pathFrame = 0;

      for (let index in this.events.path.frame) this.events.path.frame[index](this.pathFrame);
    }
  };

  this.setPosition = function (position, index = 0) {
    this.setCoordinates(position.row, position.column, position.depth, index);
  };

  this.setCoordinates = function (row, column, depth, index = 0) {
    this.data.position = {
      row,
      column,
      depth
    };
    this.offset = [Math.floor(-(row * 32) + column * 32 - 64), Math.floor(column * 16 + row * 16 - depth * 32)];
    this.index = Math.round(row) * 1000 + Math.round(column) * 1000 + depth * 100 + index;
    if (parent.door != undefined && parent.door.row == Math.round(row) && parent.door.column == Math.round(column)) this.index = -102000 + index;
  };

  this.process = function (timestamp, frame) {
    this.updatePath(frame);
  };

  this.enabled = true;

  this.enable = function () {
    this.enabled = true;
  };

  this.disable = function () {
    this.enabled = false;
  };

  return this;
};// @hash v3-1BBF25C5C24D9890100BE943784ECED2F7CEF1D2
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.sprite = function (parent, image) {
  this.parent = parent;
  this.image = image;
  this.composite = "source-over";

  this.render = function (context, room) {
    context.globalAlpha = this.getAlpha();
    context.globalCompositeOperation = this.composite;
    const offset = this.getOffset();
    context.drawImage(this.image, Math.floor(room[0] + offset[0]), Math.floor(room[1] + offset[1]));
  };

  this.offset = [0, 0];

  this.setOffset = function (left, top) {
    this.offset = [left, top];
  };

  this.getOffset = function () {
    const parentOffset = this.parent.getOffset();
    return [this.offset[0] + parentOffset[0], this.offset[1] + parentOffset[1]];
  };

  this.index = 0;

  this.getIndex = function () {
    return this.parent.index + this.index;
  };

  this.alpha = 1.0;

  this.getAlpha = function () {
    return 1.0 - (1.0 - this.alpha + (1.0 - this.parent.alpha));
  };

  this.mouseover = function (position) {
    return false;
  };

  this.mouseclick = function (event) {};

  this.mousedown = function (event) {};

  this.mousedoubleclick = function (event) {};

  return this;
};// @hash v3-529DCBFD6FEA188F8F00C35CBB09F3B070084ACD
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.cursor = function (parent) {
  const entity = new Client.rooms.items.entity(parent, "cursor");

  entity.render = async function () {
    const cursors = await Assets.getManifest("HabboRoomCursor");
    entity.sprites.length = 0;
    const sprite = new Client.rooms.items.sprite(entity, (await Assets.getSprite("HabboRoomCursor", "HabboRoomCursor_pointer")));
    sprite.setOffset(cursors.visualization["HabboRoomCursor_pointer"].offset.left, cursors.visualization["HabboRoomCursor_pointer"].offset.top);
    entity.sprites.push(sprite);
  };

  return entity;
};// @hash v3-837F295DA7B4B0398A1E529BED09774D066F7534
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.figure = function (parent, figure, direction) {
  const entity = new Client.rooms.items.entity(parent, "figure");

  entity.render = async function () {
    entity.figure = new FigureEntity(figure, {
      direction
    });
    entity.figure.events.render.push(function (sprites) {
      entity.sprites.length = 0;

      for (let index in sprites) {
        let sprite = new Client.rooms.items.sprite(entity, sprites[index].image);

        if (sprites[index].imageData != undefined) {
          sprite.mouseover = function (position) {
            const entityOffset = sprite.parent.getOffset();
            const offset = [Math.floor(position[0] - (entityOffset[0] + sprite.offset[0])), Math.floor(position[1] - (entityOffset[1] + sprite.offset[1]))];
            if (offset[0] < 0 || offset[1] < 0) return false;
            if (offset[0] > sprites[index].image.width || offset[1] > sprites[index].image.height) return false;
            const pixel = (offset[0] + offset[1] * sprites[index].imageData.width) * 4 + 3;
            if (sprites[index].imageData.data[pixel] < 50) return false;
            return true;
          };
        }

        sprite.mouseclick = function (event) {};

        sprite.setOffset(sprites[index].left - 64, sprites[index].top - (128 + 32) + 8);
        sprite.index = sprites[index].index;
        sprite.composite = sprites[index].composite == undefined ? "source-over" : sprites[index].composite;
        entity.sprites.push(sprite);
      }
    });
    entity.figure.process().then(function () {
      entity.figure.render();
    });
  };

  entity.events.path.start.push(async function () {
    if (!entity.data.walk) return;
    await entity.figure.setAction("Move");
    await entity.figure.render();
  });
  entity.events.path.frame.push(async function (frame) {
    /*if(!entity.data.walk)
        return;
      newFrame = Math.floor(frame / 2);
      if(entity.figure.frames["Move"] != newFrame) {
        entity.figure.frames["Move"] = newFrame;
          await entity.figure.render();
    }*/
  });
  entity.events.path.finish.push(async function () {
    if (!entity.data.walk) return;
    await entity.figure.removeAction("Move");
    await entity.figure.render();
  });

  entity.process = function (timestamp, frame) {
    entity.updatePath(frame);
    if (entity.figure.updateActions()) entity.figure.render();
  };

  return entity;
};// @hash v3-22785BBB8FCFC6F9B0BE026CF81A7C0C3D0DE2E5
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.map = function (parent, map = "", door = {}, floor = {}, wall = {}) {
  const entity = new Client.rooms.items.entity(parent, "map");
  entity.index = -100000;
  entity.map = new Client.rooms.map.entity(map, door, floor, wall);

  entity.render = async function () {
    await entity.map.render();
    entity.parent.center = entity.map.settings.wall.thickness + entity.map.rows * 32;
    const floor = new Client.rooms.items.sprite(entity, entity.map.$floor[0]);
    floor.index = 0;
    floor.setOffset(-entity.parent.center, -(entity.map.depth * 16));

    floor.mouseover = function (position, center) {
      const context = entity.parent.$canvas[0].getContext("2d");
      context.setTransform(1, .5, -1, .5, entity.map.rows * 32 - center, 0);

      for (let path = entity.map.floor.length - 1; path != -1; path--) {
        if (!context.isPointInPath(entity.map.floor[path].path, position[0], position[1])) continue;
        return entity.map.floor[path];
      }

      return false;
    };

    entity.sprites.push(floor);
    const $shadowCanvas = $('<canvas width="' + floor.image.width + '" height="' + (floor.image.height + 10) + '"></canvas>');
    const shadowCanvas = $shadowCanvas[0].getContext("2d");

    if (shadowCanvas.filter != undefined) {
      shadowCanvas.filter = "blur(10px) brightness(0%) opacity(50%)";
      shadowCanvas.drawImage(floor.image, 0, 10);
      shadowCanvas.filter = "blur(0) brightness(100%) opacity(100%)";
      shadowCanvas.drawImage(floor.image, 0, 0);
      const shadow = new Client.rooms.items.sprite(entity, shadowCanvas.canvas);
      shadow.index = -1000;
      shadow.setOffset(-entity.parent.center, -(entity.map.depth * 16));

      shadow.mouseover = function (position) {
        return false;
      };

      entity.sprites.push(shadow);
    }

    const wall = new Client.rooms.items.sprite(entity, entity.map.$wall[0]);
    wall.index = -2000;
    wall.setOffset(-entity.parent.center, entity.map.offset);

    wall.mouseover = function (position) {
      return false;
    };

    entity.sprites.push(wall);
  };

  return entity;
};// @hash v3-9DA9D22CBBE781D0175ADAC549C042B880889D35
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.furniture = function (parent, id, direction) {
  const entity = new Client.rooms.items.entity(parent, "furniture");
  const loading = Assets.getSpritesheet("HabboLoading").then(function (image) {
    const sprite = new Client.rooms.items.sprite(entity, image);
    sprite.setOffset(32, -32);
    entity.sprites.push(sprite);
  });
  entity.furniture = new FurnitureEntity({
    id,
    direction
  });

  entity.render = async function () {
    entity.furniture.events.render.push(function (sprites) {
      entity.sprites.length = 0;

      for (let index in sprites) {
        const layer = sprites[index];
        const sprite = new Client.rooms.items.sprite(entity, layer.sprite);
        sprite.composite = layer.ink;
        sprite.alpha = layer.alpha;
        sprite.tag = layer.tag;

        sprite.mouseover = function (position) {
          if (layer.ignoreMouse == 1) return false;
          const entityOffset = sprite.parent.getOffset();
          const offset = [Math.floor(position[0] - (entityOffset[0] + sprite.offset[0])), Math.floor(position[1] - (entityOffset[1] + sprite.offset[1]))];
          if (offset[0] < 0 || offset[1] < 0) return false;
          if (offset[0] > layer.sprite.width || offset[1] > layer.sprite.height) return false;
          const pixel = (offset[0] + offset[1] * layer.spriteData.width) * 4 + 3;
          if (layer.spriteData.data[pixel] < 50) return false;
          return true;
        };

        sprite.mouseclick = function (event) {
          if (Keys.down["ControlLeft"]) RoomInterface.furniture.pickup.start(entity);else if (Keys.down["AltLeft"]) RoomInterface.furniture.move.start(entity);else if (Keys.down["ShiftLeft"]) RoomInterface.furniture.rotate.start(entity);
        };

        sprite.mousedown = function (event) {
          if (Keys.down["ControlLeft"]) RoomInterface.furniture.pickup.start(entity);
        };

        sprite.mousedoubleclick = function (event) {
          RoomInterface.furniture.use.start(entity, sprite);
        };

        sprite.setOffset(64 - sprites[index].asset.x, 16 - sprites[index].asset.y); //sprite.index = parseInt(sprites[index].index);

        sprite.index = parseInt(sprites[index].z);
        entity.sprites.push(sprite);
      }

      if (entity.video != undefined) entity.sprites.push(entity.video);
    });
    await entity.furniture.process();
    await entity.furniture.render();
  };

  entity.process = function (timestamp, frame) {
    entity.updatePath(frame);
    if (entity.furniture.updateAnimations(timestamp)) entity.furniture.render();
  };

  return entity;
};// @hash v3-20176D0999C41367DA92C1E135AE7C3F60FD8135
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
Client.rooms.items.video = function (parent, link, time) {
  const sprite = new Client.rooms.items.sprite(parent, new Image());
  sprite.image = $('<video muted="muted"></video>')[0];
  sprite.image.addEventListener("loadeddata", function () {
    Assets.getManifest("HabboFurnitureVideos").then(function (data) {
      sprite.visualization = data.visualization[parent.furniture.settings.id];
      if (sprite.visualization == undefined) return;
      sprite.alpha = sprite.visualization.alpha == undefined ? 1.0 : sprite.visualization.alpha;
      sprite.image.currentTime = time;
      const $canvas = $('<canvas width="480" height="360"></canvas>');
      const canvas = $canvas[0].getContext("2d");
      sprite.width = 139;

      sprite.render = function (context, room) {
        if (sprite.image.paused) return;
        const direction = sprite.visualization.directions[parent.furniture.settings.direction];
        if (direction == undefined) return;
        canvas.clearRect(0, 0, canvas.canvas.width, canvas.canvas.height);
        if (parent.furniture.settings.direction == 0 || parent.furniture.settings.direction == 4) canvas.setTransform(1, .5, 0, 1, 0, 0);else if (parent.furniture.settings.direction == 2) canvas.setTransform(1, -.5, 0, 1, 0, sprite.visualization.width / 16 * 9);
        canvas.drawImage(sprite.image, 0, 0, sprite.image.videoWidth, sprite.image.videoHeight, 0, 0, sprite.visualization.width, sprite.visualization.width / 16 * 9);
        context.globalAlpha = sprite.getAlpha();
        context.globalCompositeOperation = sprite.composite;
        const offset = sprite.getOffset();
        context.drawImage($canvas[0], Math.floor(room[0] + offset[0]) + direction.left, Math.floor(room[1] + offset[1]) + direction.top);
      };

      sprite.image.play();
    });
  });
  sprite.image.src = link;
  return sprite;
};// @hash v3-0EEDCF45FE4C07703A2C9306A5326E9D716EDF7A
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomInterface = new function () {
  this.$element = $('<div class="room"></div>').prependTo(Client.$element);
  this.entity = new RoomEntity(this.$element);
  this.users = {};
  this.furnitures = {};
  this.active = false;
  this.frameLimit = 60;
  this.frameLimitStamp = null;
  this.frameAdjust = 2;
  this.frameAdjustTimestamp = performance.now();
  this.frameAdjustCounts = [];
  this.events = {
    start: [],
    stop: []
  };

  this.start = function () {
    if (this.active == true) return;
    this.active = true;

    for (let index in this.events.start) this.events.start[index]();

    this.frameLimitStamp = performance.now();
    window.requestAnimationFrame(this.render);
  };

  this.stop = async function () {
    RoomInterface.active = false;

    for (let index in RoomInterface.events.stop) RoomInterface.events.stop[index]();

    return new Promise(function (resolve) {
      window.requestAnimationFrame(function () {
        window.requestAnimationFrame(function () {
          resolve();
        });
      });
    });
  };

  this.render = function () {
    if (!RoomInterface.active) return;
    window.requestAnimationFrame(RoomInterface.render);

    if (RoomInterface.frameLimit != 0) {
      let timestamp = performance.now();
      const delta = timestamp - RoomInterface.frameLimitStamp;
      const interval = 1000 / RoomInterface.frameLimit;

      if (delta > interval) {
        RoomInterface.frameLimitStamp = timestamp - delta % interval;
        timestamp = performance.now();
        const {
          median,
          milliseconds,
          frames
        } = RoomInterface.entity.render();

        if (timestamp - RoomInterface.frameAdjustTimestamp > 1000) {
          RoomInterface.frameAdjustTimestamp = timestamp;
          RoomInterface.frameAdjustCounts.push(frames);

          if (RoomInterface.frameAdjustCounts.length == 5) {
            RoomInterface.frameAdjustCounts.splice(0, 1); //console.log("median of frames per seconds in 5 seconds is " + Client.utils.getArrayMedian(RoomInterface.frameAdjustCounts));
          } //console.log("we have rendered " + frames + " frames and we wanted " + RoomInterface.frameLimit + ", render took " + Math.round(performance.now() - timestamp) + "ms, we can afford " + Math.floor(1000 / (performance.now() - timestamp)) + " frames");

        }
        /*if((RoomInterface.frameLimit - frames) > 3) {
            console.warn("[RoomInterface]%c We're detecting an urge for more frames (" + frames + "/" + RoomInterface.frameLimit + ") than we can deliver, render took " + median + "/" + interval + "!", "color: lightblue");
              if(RoomInterface.frameLimit > 12) {
                RoomInterface.frameLimit -= 2;
                  if(RoomInterface.frameLimit < 12)
                    RoomInterface.frameLimit = 12;
                  console.warn("[RoomInterface]%c Lowered expected frame count down to " + RoomInterface.frameLimit + "!", "color: lightblue");
            }
            
        }*/

      }
    } else RoomInterface.entity.render();
  };

  this.clear = async function () {
    this.chat.clear();
    this.entity.entities.length = 0;
    if (this.active) await this.stop();
  };
}();// @hash v3-5827D26D2FD2A986519B02F432236CCA7B28F6BF
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomInterface.chat = new function () {
  this.$element = $('<div class="room-interface-chat"></div>').appendTo(RoomInterface.$element);
  this.interval = null;
  this.messages = [];

  this.startInterval = function () {
    if (this.interval != null) return;
    this.stopInterval();
    this.interval = setInterval(function () {
      RoomInterface.chat.updateMessages();
    }, 3 * 1000);
  };

  this.stopInterval = function () {
    if (this.interval != null) clearInterval(this.interval);
    this.interval = null;
  };

  this.clear = function () {
    for (let index in this.messages) this.messages[index].remove();

    this.messages.length = 0;
  };

  this.addMessage = async function (style, message, center = 0, color = undefined) {
    let sprite = await Assets.getSprite("HabboRoomChat", "HabboRoomChat_" + style);
    if (color != undefined) sprite = await Assets.getSpriteColor("HabboRoomChat", "HabboRoomChat_" + style, color);
    const $canvas = $('<canvas class="room-interface-chat-message"></canvas>');
    const context = $canvas[0].getContext("2d");
    const visualization = JSON.parse(JSON.stringify(this.assets.visualization["default"]));

    if (this.assets.visualization["HabboRoomChat_" + style] != undefined) {
      for (let key in this.assets.visualization["HabboRoomChat_" + style]) {
        visualization[key] = this.assets.visualization["HabboRoomChat_" + style][key];
      }
    }

    const parts = Client.utils.getStringMarkup(message);
    let messageWidth = 0;

    for (let index in parts) {
      context.font = "13px " + visualization.font + " " + parts[index].type;
      parts[index].width = context.measureText(parts[index].message).width;
      messageWidth += parts[index].width;
    }

    context.canvas.width = visualization.left + messageWidth + visualization.width;
    context.canvas.height = sprite.height;
    context.font = "13px " + visualization.font;
    context.drawImage(sprite, 0, 0, visualization.left, context.canvas.height, 0, 0, visualization.left, context.canvas.height);
    context.drawImage(sprite, visualization.left, visualization.top, visualization.width, context.canvas.height, visualization.left, visualization.top, messageWidth, context.canvas.height);
    context.drawImage(sprite, visualization.left + visualization.width, 0, sprite.width - (visualization.left + visualization.width), context.canvas.height, visualization.left + messageWidth, 0, sprite.width - (visualization.left + visualization.width), context.canvas.height);
    let left = 0;
    context.fillStyle = visualization.color;

    for (let index in parts) {
      context.font = "13px " + visualization.font + " " + parts[index].type;
      context.fillText(parts[index].message, visualization.left + left, context.canvas.height - visualization.offset);
      left += parts[index].width;
    }

    $canvas.css("left", center - context.canvas.width / 2);
    this.messages.push($canvas);
    this.history.addMessage(context.canvas, center - context.canvas.width / 2);
    $canvas.appendTo(this.$element);
    this.updateMessages();
    this.startInterval();
  };

  this.updateMessages = function () {
    for (let index = 0; index < this.messages.length; index++) {
      const top = parseInt(this.messages[index].css("top"));

      if (top < 0) {
        this.messages[index].remove();
        this.messages.splice(index, 1);
        continue;
      }

      this.messages[index].animate({
        "top": "-=30"
      }, 400);
    }

    if (this.messages.length == 0) this.stopInterval();
  };

  this.render = function () {
    if (this.messages.length == 0) return;
    if (this.margin == RoomInterface.entity.offset[0]) return;
    this.margin = RoomInterface.entity.offset[0];
    this.$element.css("margin-left", RoomInterface.entity.offset[0] + "px");
  };

  RoomInterface.entity.events.render.push(function () {
    RoomInterface.chat.render();
  });
}();
Loader.addAsset(async function () {
  RoomInterface.chat.assets = await Assets.getManifest("HabboRoomChat");
});// @hash v3-1DC84D0BCF3294A8A7EA483E5C3359593670679C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomInterface.chat.input = new function () {
  this.$element = $('<div class="room-interface-chat-input"></div>').appendTo(RoomInterface.$element);
  this.$input = $('<input type="text" placeholder="Click here to chat...">').appendTo(this.$element);
  this.$input.on("keyup", function (event) {
    if (event.key != "Enter") return;
    if ($(this).val().length == 0) return;
    SocketMessages.send({
      OnRoomUserChat: $(this).val()
    });
    $(this).val("");
  });
}();// @hash v3-C0C0B9F9CC4B9E26086AB96E3AE800DC6CC6CB91
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomInterface.chat.history = new function () {
  this.$element = $('<div class="room-interface-chat-history">' + '<div class="room-interface-chat-history-messages">' + '<div class="room-interface-chat-history-messages-content"></div>' + '</div>' + '<div class="room-interface-chat-history-handle">' + '<div class="room-interface-chat-history-button"></div>' + '</div>' + '</div>').appendTo(RoomInterface.$element);
  this.$messages = this.$element.find(".room-interface-chat-history-messages-content");
  this.$button = this.$element.find(".room-interface-chat-history-button");
  this.mouseDown = false;
  this.mousePosition = false;

  this.mouseMove = function (event) {
    if (!RoomInterface.chat.history.mouseDown) return;
    let height = RoomInterface.chat.history.$element.height() + (event.clientY - RoomInterface.chat.history.mousePosition);
    if (height < 30 || height > $(window).height() / 2) return;

    if (height < 50 && height < RoomInterface.chat.history.$element.height()) {
      height = 30;
      RoomInterface.chat.history.mouseDown = false;
      $(window).unbind("mouseup", RoomInterface.chat.history.mouseUp);
      $(window).unbind("mousemove", RoomInterface.chat.history.mouseMove);
    }

    RoomInterface.chat.history.$messages[0].scrollTop += RoomInterface.chat.history.$element.height() - height;
    RoomInterface.chat.history.$element.css({
      "height": height + "px"
    });
    RoomInterface.chat.history.mousePosition = event.clientY;
  };

  this.mouseUp = function (event) {
    if (!RoomInterface.chat.history.mouseDown) return;
    RoomInterface.chat.history.mouseDown = false;
    $(window).unbind("mouseup", RoomInterface.chat.history.mouseUp);
    $(window).unbind("mousemove", RoomInterface.chat.history.mouseMove);
  };

  this.$button.on("mousedown", function (event) {
    RoomInterface.chat.history.mouseDown = true;
    RoomInterface.chat.history.mousePosition = event.clientY;
    $(window).bind("mouseup", RoomInterface.chat.history.mouseUp);
    $(window).bind("mousemove", RoomInterface.chat.history.mouseMove);
  });
  this.messages = [];

  this.addMessage = function (image, left) {
    const previousScroll = this.$messages[0].scrollTop;
    const $canvas = $('<canvas class="room-interface-chat-message" width="' + image.width + '" height="' + image.height + '"></canvas>').css("margin-left", RoomInterface.entity.offset[0] + left).appendTo(this.$messages);
    const context = $canvas[0].getContext("2d");
    context.drawImage(image, 0, 0);
    this.$messages[0].scrollTop += this.$messages[0].scrollHeight - previousScroll;
    this.messages.push($canvas);
  };

  this.reset = function () {
    for (let index in this.messages) this.messages[index].remove();

    this.messages.length = 0;
    this.$element.css({
      "height": "30px"
    });
  };
}();
RoomInterface.events.stop.push(function () {
  RoomInterface.chat.history.reset();
});// @hash v3-EB671153552AEB122F916155C2E2D67234D22BB6
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomUserChat", async function (data) {
  const user = RoomInterface.users[data.id];
  const center = RoomInterface.entity.center;
  const position = RoomInterface.entity.offset;
  const offset = user.getOffset();
  RoomInterface.chat.addMessage("bot_a", "**" + user.data.name + ":** " + data.message, center + offset[0] + 64);
  await user.figure.setAction("Talk");
  setTimeout(async function () {
    await user.figure.removeAction("Talk");
    user.figure.render();
  }, data.message.length * 100);
});// @hash v3-9F3E5CE0EFCC5F38B8B2AFAE6492987E41E5974D
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomInterface.cursor = new function () {
  this.down = false;
  this.downTimestamp = 0;
  this.downFrame = 0;
  this.position = null;
  this.events = {
    hover: [],
    unhover: [],
    click: [],
    doubleclick: []
  };
  RoomInterface.entity.$canvas.on("mousedown", function (event) {
    RoomInterface.cursor.down = true;
    RoomInterface.cursor.downTimestamp = performance.now();
    RoomInterface.cursor.position = [event.offsetX, event.offsetY];

    if (RoomInterface.frameLimit != 0) {
      RoomInterface.cursor.downFrame = RoomInterface.frameLimit;
      RoomInterface.frameLimit = 0;
    }
  }).on("mouseup", function () {
    RoomInterface.cursor.down = false;
    RoomInterface.frameLimit = RoomInterface.cursor.downFrame;
  }).on("mousemove", function (event) {
    if (RoomInterface.entity.currentEntity != undefined && RoomInterface.cursor.down) RoomInterface.entity.currentEntity.sprite.mousedown(event);

    if (!RoomInterface.cursor.down || Keys.down["ControlLeft"] || Keys.down["ShiftLeft"] || Keys.down["AltLeft"]) {
      RoomInterface.cursor.position = [event.offsetX, event.offsetY];
      return;
    }

    RoomInterface.entity.offset[0] += event.offsetX - RoomInterface.cursor.position[0];
    RoomInterface.entity.offset[1] += event.offsetY - RoomInterface.cursor.position[1];
    RoomInterface.cursor.position = [event.offsetX, event.offsetY];
  }).on("touchstart", function (event) {
    RoomInterface.cursor.position = [event.touches[0].clientX, event.touches[0].clientY];
    RoomInterface.cursor.down = true;
  }).on("touchmove", function (event) {
    if (RoomInterface.cursor.position == null) RoomInterface.cursor.position = [event.touches[0].clientX, event.touches[0].clientY];
    if (!RoomInterface.cursor.down) return;
    RoomInterface.entity.offset[0] += event.touches[0].clientX - RoomInterface.cursor.position[0];
    RoomInterface.entity.offset[1] += event.touches[0].clientY - RoomInterface.cursor.position[1];
    RoomInterface.cursor.position = [event.touches[0].clientX, event.touches[0].clientY];
  }).on("touchend", function (event) {
    RoomInterface.cursor.down = false;
  }).on("dblclick", function (event) {
    if (RoomInterface.furniture.place.enabled) return;
    if (RoomInterface.entity.currentEntity != undefined) RoomInterface.entity.currentEntity.sprite.mousedoubleclick(event);

    for (let index in RoomInterface.cursor.events.doubleclick) RoomInterface.cursor.events.doubleclick[index](RoomInterface.entity.currentEntity, event);
  }).on("click", function (event) {
    if (performance.now() - RoomInterface.cursor.downTimestamp > 250) return;

    if (RoomInterface.furniture.place.enabled) {
      RoomInterface.furniture.place.click();
      return;
    }

    if (RoomInterface.entity.currentMapEntity != undefined) {
      if (!(Keys.down["ControlLeft"] || Keys.down["ShiftLeft"] || Keys.down["AltLeft"])) SocketMessages.send({
        OnRoomMapClick: {
          row: RoomInterface.entity.currentMapEntity.result.row,
          column: RoomInterface.entity.currentMapEntity.result.column
        }
      });
    }

    if (RoomInterface.entity.currentEntity != undefined) RoomInterface.entity.currentEntity.sprite.mouseclick(event);

    for (let index in RoomInterface.cursor.events.click) RoomInterface.cursor.events.click[index](RoomInterface.entity.currentEntity, event);
  }).on("mouseout", function () {
    RoomInterface.cursor.down = false;
    RoomInterface.cursor.position = [0, 0];
  });
  const cursor = new Client.rooms.items.furniture(RoomInterface.entity, "HabboRoomCursor", 0);
  cursor.name = "cursor";
  cursor.render();
  cursor.disable();
  RoomInterface.events.start.push(function () {
    RoomInterface.entity.addEntity(cursor);
  });
  RoomInterface.entity.events.render.push(function () {
    RoomInterface.entity.currentMapEntity = RoomInterface.entity.getEntity(RoomInterface.cursor.position, "map");

    if (RoomInterface.entity.currentMapEntity == undefined) {
      if (cursor.enabled) {
        cursor.disable();

        for (let index in RoomInterface.cursor.events.unhover) RoomInterface.cursor.events.unhover[index]();
      }
    } else {
      const row = parseInt(RoomInterface.entity.currentMapEntity.result.row),
            column = parseInt(RoomInterface.entity.currentMapEntity.result.column),
            depth = Math.round(RoomInterface.entity.currentMapEntity.result.depth);
      cursor.setCoordinates(row, column, depth, -2000);
      cursor.enable();

      for (let index in RoomInterface.cursor.events.hover) RoomInterface.cursor.events.hover[index]({
        row,
        column,
        depth
      });
    }

    RoomInterface.entity.currentEntity = RoomInterface.entity.getEntity(RoomInterface.cursor.position);
  });
}();// @hash v3-55556613D771E4F463AE3858066C5133AD709C43
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomInterface.display = new function () {
  this.$element = $('<div class="room-interface-display">' + '<div class="room-interface-display-content"></div>' + '<div class="room-interface-display-buttons"></div>' + '</div>').hide().appendTo(RoomInterface.$element);
  this.$content = this.$element.find(".room-interface-display-content");
  this.$buttons = this.$element.find(".room-interface-display-buttons");

  this.addButton = function (text, click) {
    const $element = $('<div class="room-interface-display-button">' + text + '</div>').appendTo(this.$buttons);
    +$element.click(click);
  };

  this.figure = async function (entity) {
    this.entity = entity;
    this.$element.hide();
    this.$content.html("");
    this.$buttons.html("");
    const $header = $('<div class="room-interface-display-title">' + entity.data.name + '</div>').appendTo(this.$content);
    $('<div class="room-interface-display-break"></div>').appendTo(this.$content);
    const $grid = $('<div class="room-interface-display-grid"></div>').appendTo(this.$content);
    const $figure = $('<div class="room-interface-display-figure room-interface-display-bot"></div>').appendTo($grid);
    const $canvas = $('<canvas width="256" height="256"></canvas>').appendTo($figure);
    new FigureRenderer(entity.data.figure, {
      direction: 4
    }, $canvas);
    const $badges = $('<div class="room-interface-display-badges"></div>').appendTo($grid);
    const $badge = [];
    $badge[0] = $('<div class="room-interface-display-badge"></div>').appendTo($badges);
    $('<div class="room-interface-display-group"></div>').appendTo($badges);

    for (let index = 1; index < 5; index++) $badge[index] = $('<div class="room-interface-display-badge"></div>').appendTo($badges);

    SocketMessages.sendCall({
      OnUserBadgeRequest: entity.data.id
    }, "OnUserBadgeRequest").then(function (badges) {
      for (let index in badges) new BadgeRenderer(badges[index].badge).appendTo($badge[index]);
    });
    this.$element.show();
  };

  this.furniture = async function (entity) {
    this.entity = entity;
    this.$element.hide();
    this.$content.html("");
    this.$buttons.html("");
    const furniture = await Furnitures.get(entity.furniture.settings.id);
    const $header = $('<div class="room-interface-display-title">' + furniture.title + '</div>').appendTo(this.$content);
    $('<div class="room-interface-display-break"></div>').appendTo(this.$content);
    const $canvas = $('<canvas class="room-interface-display-canvas"></canvas>').appendTo(this.$content);

    if (furniture.description.length != 0) {
      $('<div class="room-interface-display-break"></div>').appendTo(this.$content);
      $('<div class="room-interface-display-description">' + furniture.description + '</div>').appendTo(this.$content);
    }

    new FurnitureRenderer({
      id: furniture.id,
      direction: 4
    }, $canvas, "rgb(28, 28, 26)");
    this.addButton('Edit <i class="sprite-beta"></i>', function () {
      Client.development.furni.set(entity);
    });

    if (RoomInterface.data.rights.includes(Client.user.id) || entity.data.user == Client.user.id) {
      this.addButton("Pickup", function () {
        RoomInterface.furniture.pickup.start(entity);
      });
    }

    if (RoomInterface.data.rights.includes(Client.user.id)) {
      this.addButton("Rotate", function () {
        RoomInterface.furniture.rotate.start(entity);
      });
      this.addButton("Move", function () {
        RoomInterface.furniture.move.start(entity);
      });

      if (RoomInterface.furniture.logics[entity.furniture.types.logic] != undefined) {
        this.addButton("Use", function () {
          RoomInterface.furniture.use.start(entity);
        });
      }
    }

    this.$element.show();
  };

  this.hide = function () {
    RoomInterface.display.entity = undefined;
    RoomInterface.display.$element.hide();
  };

  RoomInterface.cursor.events.click.push(function (entity) {
    if (entity == undefined) {
      RoomInterface.display.hide();
      return;
    }

    switch (entity.entity.name) {
      case "furniture":
        RoomInterface.display.furniture(entity.entity);
        break;

      case "figure":
        RoomInterface.display.figure(entity.entity);
        break;
    }
  });
}();// @hash v3-4F54F15DC8204F707DEC132C8E3A8010814D3808
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomInterface.display.users = new function () {
  this.tabs = new function () {
    this.entity = undefined;
    this.$element = $('<div class="room-interface-user"></div>').appendTo(RoomInterface.$element);

    this.click = function (entity) {
      this.$element.html('<div class="room-interface-user-header">' + entity.entity.data.name + '</div>' + '<div class="room-interface-user-content"></div>' + '<div class="room-interface-user-footer"></div>' + '<div class="room-interface-user-arrow"></div>');

      if (Client.theme.get("rooms/interface/tabs/figure", false) == true) {
        this.$canvas = $('<canvas class="room-interface-user-figure" width="256" height="256"></canvas>').appendTo(this.$element);
        entity.entity.figure.events.render.push(this.render);
      }

      this.$content = this.$element.find(".room-interface-user-content");
      this.entity = entity;
      this.show("default");
    };

    this.render = function (sprites) {
      const entity = RoomInterface.display.users.tabs;
      const context = entity.$canvas[0].getContext("2d");
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);

      for (let index in sprites) context.drawImage(sprites[index].image, sprites[index].left, sprites[index].top);
    };

    this.show = async function (page, previous = "default") {
      this.$content.html("");

      switch (page) {
        case "default":
          {
            if (Client.user.id == this.entity.entity.data.id) {
              this.add("Actions", function () {
                RoomInterface.display.users.tabs.show("actions", "default");
              });
            } else {
              this.add("Manage", function () {
                RoomInterface.display.users.tabs.show("manage", "default");
              });
            }

            if (RoomInterface.data.rights.includes(Client.user.id) && Client.user.id != this.entity.entity.data.id) {
              this.add("Moderate", function () {
                RoomInterface.display.users.tabs.show("moderate", "default");
              });
            }

            break;
          }

        case "manage":
          {
            const friend = Client.user.friends[this.entity.entity.data.id];

            if (friend != undefined) {
              if (friend.status == -1) {
                this.add("Cancel Friend Invite", async function () {
                  await SocketMessages.sendCall({
                    OnUserFriendRemove: {
                      user: RoomInterface.display.users.tabs.entity.entity.data.id
                    }
                  }, "OnUserFriendRemove");
                  RoomInterface.display.users.tabs.hide();
                });
              } else if (friend.status == 0) {
                this.add("Accept Friend Invite", async function () {
                  await SocketMessages.sendCall({
                    OnUserFriendAdd: {
                      user: RoomInterface.display.users.tabs.entity.entity.data.id
                    }
                  }, "OnUserFriendAdd");
                  RoomInterface.display.users.tabs.hide();
                });
              } else {
                this.add("Remove Friend Invite", async function () {
                  await SocketMessages.sendCall({
                    OnUserFriendRemove: {
                      user: RoomInterface.display.users.tabs.entity.entity.data.id
                    }
                  }, "OnUserFriendRemove");
                  RoomInterface.display.users.tabs.hide();
                });
              }
            } else {
              this.add("Send Friend Invite", async function () {
                await SocketMessages.sendCall({
                  OnUserFriendAdd: {
                    user: RoomInterface.display.users.tabs.entity.entity.data.id
                  }
                }, "OnUserFriendAdd");
                RoomInterface.display.users.tabs.hide();
              });
            }

            break;
          }

        case "actions":
          {
            this.add("Wave", function () {
              SocketMessages.sendCall({
                OnRoomUserAction: "Wave"
              }, "OnRoomUserAction");
              RoomInterface.display.users.tabs.hide();
            });
            this.add("Blow", function () {
              SocketMessages.sendCall({
                OnRoomUserAction: "Blow"
              }, "OnRoomUserAction");
              RoomInterface.display.users.tabs.hide();
            });
            this.add("Laugh", function () {
              SocketMessages.sendCall({
                OnRoomUserAction: "Laugh"
              }, "OnRoomUserAction");
              RoomInterface.display.users.tabs.hide();
            });
            this.add("Idle", function () {
              SocketMessages.sendCall({
                OnRoomUserAction: "Idle"
              }, "OnRoomUserAction");
              RoomInterface.display.users.tabs.hide();
            });
            break;
          }

        case "moderate":
          {
            if (Client.user.id == RoomInterface.data.user) {
              RoomInterface.data.rights = await SocketMessages.sendCall({
                OnRoomRightsUpdate: null
              }, "OnRoomRightsUpdate");
              this.add((RoomInterface.data.rights.includes(this.entity.entity.data.id) ? "Revoke" : "Grant") + " Rights", async function () {
                await SocketMessages.sendCall({
                  OnRoomRightsUpdate: {
                    user: RoomInterface.display.users.tabs.entity.entity.data.id
                  }
                }, "OnRoomRightsUpdate");
                RoomInterface.display.users.tabs.show("moderate", "default");
              });
            }

            break;
          }
      }

      if (page != previous) {
        this.add("Back", function () {
          RoomInterface.display.users.tabs.show(previous, "default");
        });
      }
    };

    this.add = function (text, click) {
      const $element = $('<div class="room-interface-user-item">' + text + '</div>');
      $element.on("click", function () {
        click();
      });
      $element.appendTo(this.$content);
    };

    this.hide = function () {
      if (this.$canvas != undefined) {
        const index = this.entity.entity.figure.events.render.indexOf(this.render);
        this.entity.entity.figure.events.render.splice(index, 1);
        this.$canvas.remove();
        delete this.$canvas;
      }

      this.entity = undefined;
      this.$element.hide();
    };

    this.hover = function () {
      if (this.entity == undefined) return;
      const center = RoomInterface.entity.center;
      const position = RoomInterface.entity.offset;
      const offset = this.entity.entity.getOffset();
      this.$element.css({
        "left": center + position[0] + offset[0],
        "bottom": RoomInterface.$element.height() - (position[1] + offset[1])
      }).show();
    };

    RoomInterface.cursor.events.click.push(function (entity) {
      if (entity == undefined || entity.entity.name != "figure") {
        RoomInterface.display.users.tabs.hide();
        return;
      }

      RoomInterface.display.users.tabs.hide();
      RoomInterface.display.users.tabs.click(entity);
    });
    RoomInterface.entity.events.render.push(function () {
      RoomInterface.display.users.tabs.hover();
    });
  }();

  this.request = function (entity) {
    const $element = $('<div class="room-interface-user room-interface-user-request">' + '<div class="user-profile" data-user="' + entity.data.id + '"><i class="sprite-user-profile"></i> <b>Friend request from ' + entity.data.name + '</b></div>' + '<div class="room-interface-user-request-close"></div>' + '<div class="room-interface-user-request-buttons">' + '<div class="room-interface-user-request-decline dialog-button">Decline</div>' + '<div class="room-interface-user-request-accept dialog-button"><i class="sprite-success"></i> Accept</div>' + '</div>' + '<div class="room-interface-user-arrow"></div>' + '</div>').appendTo(RoomInterface.$element);
    $element.find(".room-interface-user-request-close").on("click", function () {
      destroy();
    });
    $element.find(".room-interface-user-request-decline").on("click", async function () {
      await SocketMessages.sendCall({
        OnUserFriendRemove: {
          user: entity.data.id
        }
      }, "OnUserFriendRemove");
      destroy();
    });
    $element.find(".room-interface-user-request-accept").on("click", async function () {
      await SocketMessages.sendCall({
        OnUserFriendAdd: {
          user: entity.data.id
        }
      }, "OnUserFriendUpdate");
      destroy();
    });

    function destroy() {
      const index = RoomInterface.entity.events.render.indexOf(hover);
      RoomInterface.entity.events.render.splice(index, 1);
      $element.remove();
    }

    ;
    this.destroy = destroy;

    function hover() {
      const center = RoomInterface.entity.center;
      const position = RoomInterface.entity.offset;
      const offset = entity.getOffset();
      $element.css({
        "left": center + position[0] + offset[0],
        "bottom": RoomInterface.$element.height() - (position[1] + offset[1])
      }).show();
    }

    ;
    RoomInterface.entity.events.render.push(hover);
  };

  this.$name = $('<div class="room-interface-user"></div>').appendTo(RoomInterface.$element);

  this.hover = function (entity) {
    if (entity == undefined || entity.entity.name != "figure") {
      this.$name.hide();
      return;
    }

    if (RoomInterface.display.users.tabs.entity != undefined && entity.entity == RoomInterface.display.users.tabs.entity.entity) {
      this.$name.hide();
      return;
    }

    this.$name.html('<div class="room-interface-user-title">' + entity.entity.data.name + '</div>' + '<div class="room-interface-user-arrow"></div>');
    const center = RoomInterface.entity.center;
    const position = RoomInterface.entity.offset;
    const offset = entity.entity.getOffset();
    this.$name.css({
      "left": center + position[0] + offset[0],
      "bottom": RoomInterface.$element.height() - (position[1] + offset[1])
    }).show();
  };

  RoomInterface.entity.events.render.push(function () {
    const entity = RoomInterface.entity.currentEntity;
    RoomInterface.display.users.hover(entity);
  });
  RoomInterface.events.stop.push(function () {
    RoomInterface.display.users.tabs.hide();

    for (let id in RoomInterface.users) if (RoomInterface.users[id].request != undefined) RoomInterface.users[id].request.destroy();
  });
}();// @hash v3-FC4EACB17A9FFB2C4A0B0F76487E53CF99E6311A
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomInterface.menu = new function () {
  this.$element = $('<div class="room-interface-menu active">' + '<div class="room-interface-menu-toggle"></div>' + '<div class="room-interface-menu-content"></div>' + '</div>').appendTo(RoomInterface.$element);
  this.$toggle = this.$element.find(".room-interface-menu-toggle");
  this.$toggle.on("click", function () {
    $(this).parent().toggleClass("active");
  });
  this.$content = this.$element.find(".room-interface-menu-content");

  this.link = function (identifier, title, click) {
    const $element = $('<div class="room-interface-menu-link room-interface-menu-' + identifier + '">' + title + '</div>').appendTo(this.$content);
    $element.on("click", function () {
      click();
    });
    return $element;
  };

  this.link("information", "Information", function () {
    RoomInterface.information.toggle();
  });
  const $settings = this.link("settings", "Settings", function () {
    Client.rooms.settings.toggle();
  });
  RoomInterface.events.start.push(function () {
    if (RoomInterface.data.user == Client.user.id) $settings.show();else $settings.hide();
  });
}();// @hash v3-74129C0935ACB11DBDEE4AB3D7C805E8F710D71C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
RoomInterface.information = new function () {
  const entity = new Dialog({
    title: "Room Information",
    size: {
      width: 240
    },
    offset: {
      type: "center",
      top: -120
    }
  });
  entity.events.create.push(function () {
    entity.$content.addClass("room-interface-information");
    entity.$title = $('<p class="room-interface-information-title"></p>').appendTo(entity.$content);
    entity.$owner = $('<p class="room-interface-information-owner"></p>').appendTo(entity.$content);
    entity.$description = $('<p class="room-interface-information-description"></p>').appendTo(entity.$content);
    entity.$thumbnail = $('<div class="room-interface-information-thumbnail"></div>').appendTo(entity.$content);
  });
  entity.events.show.push(function () {
    entity.$title.text(RoomInterface.data.title);
    entity.$owner.text("");
    entity.$description.text(RoomInterface.data.description == undefined ? "" : RoomInterface.data.description);
    Game.getUser(RoomInterface.data.user).then(function (user) {
      entity.$owner.text("By " + user.name);
    });
  });
  RoomInterface.events.stop.push(function () {
    if (entity.active) entity.hide();
  });
  return entity;
}();// @hash v3-E3803B81DFA0431D41C28DAB750C8F914C61C75C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomEnter", async function (data) {
  RoomInterface.entity.door = undefined;
  if (data.map.floor[data.map.door.row + 1] == undefined || data.map.floor[data.map.door.row + 1][data.map.door.column] == 'X') RoomInterface.entity.door = data.map.door;
  Client.rooms.navigator.hide();
  await RoomInterface.clear();
  RoomInterface.data = data;
  SocketMessages.sendCall({
    OnRoomMapStackUpdate: null
  }, "OnRoomMapStackUpdate").then(function (result) {
    RoomInterface.data.map.stack = result;
  });
  RoomInterface.map = new Client.rooms.items.map(RoomInterface.entity, data.map.floor, data.map.door, {
    thickness: data.floor_thickness,
    material: data.floor_material
  }, {
    thickness: data.wall_thickness,
    material: data.wall_material
  });
  RoomInterface.map.render().then(function () {
    RoomInterface.entity.addEntity(RoomInterface.map);
    const width = RoomInterface.$element.width(),
          height = RoomInterface.$element.height();
    RoomInterface.entity.offset = [width / 2 - (RoomInterface.map.map.rows * 16 + RoomInterface.map.map.columns * 16), height / 2 - (RoomInterface.map.map.rows * 8 + RoomInterface.map.map.columns * 8)];
  });
  RoomInterface.start();
});// @hash v3-B59CB2D780C2A8C7C1A0D6C2680A0A66AFCDF0C8
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomEntityAdd", async function (data) {
  if (data.furnitures != undefined) {
    if (data.furnitures.length == undefined) data.furnitures = [data.furnitures];

    for (let index in data.furnitures) {
      const dataFurniture = data.furnitures[index];
      let entity = new Client.rooms.items.furniture(RoomInterface.entity, dataFurniture.furniture, dataFurniture.position.direction);
      entity.setPosition(dataFurniture.position);
      if (dataFurniture.animation) entity.furniture.update({
        animation: dataFurniture.animation
      });
      entity.render();
      entity.data = data.furnitures[index];
      RoomInterface.entity.addEntity(entity);
      RoomInterface.furnitures[dataFurniture.id] = entity;
    }
  }

  if (data.users != undefined) {
    if (data.users.length == undefined) data.users = [data.users];

    for (let index in data.users) {
      let entity = new Client.rooms.items.figure(RoomInterface.entity, data.users[index].figure, data.users[index].position.direction);
      entity.setPosition(data.users[index].position);
      entity.render();

      if (data.users[index].actions != undefined) {
        await entity.figure.setActions(data.users[index].actions);
        entity.figure.render();
      }

      entity.data = data.users[index];
      RoomInterface.entity.addEntity(entity);
      RoomInterface.users[data.users[index].id] = entity;
      const friend = Client.user.friends[data.users[index].id];

      if (friend != undefined) {
        if (friend.status == 0 && friend.request == undefined) friend.request = new RoomInterface.display.users.request(RoomInterface.users[data.users[index].id]);
      }
    }
  }
});// @hash v3-AB314DBD6D6E5CA3A1AE22B79043C920CAF0FA6C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomEntityUpdate", async function (data) {
  for (let key in data) {
    for (let index in data[key]) {
      const item = data[key][index];
      const entity = RoomInterface[key][index];

      if (item.position != undefined) {
        if (item.position.row != undefined && item.position.column != undefined && item.position.depth != undefined) {
          entity.stopPath(true);

          if (item.position.speed != 0) {
            if (key == "users") entity.data.walk = item.position.walk == undefined ? false : item.position.walk;
            entity.setPath(entity.data.position, item.position, item.position.speed);
          } else entity.setCoordinates(item.position.row, item.position.column, item.position.depth);
        }
      }

      for (let property in item) RoomInterface[key][index].data[property] = item[property];
    }
  }

  if (data.users != undefined) {
    for (let index in data.users) {
      let render = false;

      if (data.users[index].position != undefined) {
        if (data.users[index].position.direction != undefined) {
          RoomInterface.users[index].figure.direction = data.users[index].position.direction;
          render = true;
        }

        if (data.users[index].position.actions != undefined) {
          await RoomInterface.users[index].figure.setActions(data.users[index].position.actions);
          render = true;
        }
      }

      if (data.users[index].action != undefined) {
        await RoomInterface.users[index].figure.setAction(data.users[index].action.action);
        setTimeout(async function () {
          await RoomInterface.users[index].figure.removeAction(data.users[index].action.action);
          RoomInterface.users[index].figure.render();
        }, data.users[index].action.time);
      }

      RoomInterface.users[index].figure.render();
    }
  }

  if (data.furnitures != undefined) {
    for (let index in data.furnitures) {
      if (data.furnitures[index].animation != undefined) {
        RoomInterface.furnitures[index].furniture.setAnimation(data.furnitures[index].animation);
      }

      if (data.furnitures[index].position != undefined) {
        if (data.furnitures[index].position.direction != undefined) {
          RoomInterface.furnitures[index].furniture.setDirection(data.furnitures[index].position.direction);
        }
      }

      RoomInterface.furnitures[index].furniture.render();
    }
  }
});// @hash v3-B1952A7AE0FB956233CCB10FE2ED758EC0EB2A6C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:12
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomEntityRemove", async function (data) {
  if (data.furnitures != undefined) {
    if (data.furnitures.length == undefined) data.furnitures = [data.furnitures];

    for (let index in data.furnitures) {
      const id = data.furnitures[index];
      const entity = RoomInterface.furnitures[id];
      if (RoomInterface.display.entity == entity) RoomInterface.display.hide();
      RoomInterface.entity.removeEntity(entity);
      delete RoomInterface.furnitures[id];
    }
  }

  if (data.users != undefined) {
    if (data.users.length == undefined) data.users = [data.users];

    for (let index in data.users) {
      const id = data.users[index];
      const entity = RoomInterface.users[id];
      if (RoomInterface.display.entity == entity) RoomInterface.display.hide();
      RoomInterface.entity.removeEntity(entity);
      delete RoomInterface.users[id];
    }
  }
});// @hash v3-87E400730A3907261CC848787DE51CF2EA0ADDB9
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomFurnitureVideoStart", function (data) {
  const entity = RoomInterface.furnitures[data.id];
  if (entity == undefined) return;

  if (entity.video != undefined) {
    entity.video.image.pause();
    $(entity.video.image).remove();
    delete entity.video;
  }

  entity.video = new Client.rooms.items.video(entity, Loader.settings.api.youtube + data.video + ".mp4", data.time == undefined ? 0 : data.time);
  entity.sprites.push(entity.video);
});
SocketMessages.register("OnRoomFurnitureVideoStop", function (data) {
  const entity = RoomInterface.furnitures[data];
  if (entity == undefined) return;
  if (entity.video == undefined) return;
  entity.video.image.pause();
  $(entity.video.image).remove();
  delete entity.video;
});// @hash v3-397D2C66710AA7AA488208C8B9433E5DB2043AFE
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomFurnitureFlash", function (data) {
  const furnitures = [];

  for (let id in RoomInterface.furnitures) {
    const entity = RoomInterface.furnitures[id];
    if (entity.data.furniture != data.id) continue;
    furnitures.push(id);
  }

  function setAnimation(animation) {
    for (let index in furnitures) RoomInterface.furnitures[furnitures[index]].furniture.setAnimation(animation);
  }

  ;
  setAnimation(data.animation);
  setTimeout(function () {
    setAnimation(0);
    setTimeout(function () {
      setAnimation(data.animation);
      setTimeout(function () {
        setAnimation(0);
        setTimeout(function () {
          setAnimation(data.animation);
          setTimeout(function () {
            setAnimation(0);
          }, 500);
        }, 500);
      }, 500);
    }, 500);
  }, 500);
});// @hash v3-84B6C57085BCF5290837BE1DBF58AC11C4700249
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomUserEffect", function (data) {
  if (data.length == undefined) data = [data];

  for (let index in data) {
    const user = RoomInterface.users[data[index].id];
    if (user == undefined) continue;
    user.figure.setEffect(data[index].effect);
    user.figure.render();
  }
});// @hash v3-C5935B0D056B2862F43C7EC77933C0C271BE59F6
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomSettingsUpdate", function (data) {
  for (let key in data) RoomInterface.data[key] = data[key];

  if (data.map != undefined || data.floor_material != undefined || data.wall_material != undefined) {
    if (RoomInterface.map != undefined) RoomInterface.entity.removeEntity(RoomInterface.map);
    RoomInterface.map = new Client.rooms.items.map(RoomInterface.entity, RoomInterface.data.map.floor, RoomInterface.data.map.door, {
      thickness: RoomInterface.data.floor_thickness,
      material: RoomInterface.data.floor_material
    }, {
      thickness: RoomInterface.data.wall_thickness,
      material: RoomInterface.data.wall_material
    });
    RoomInterface.map.render().then(function () {
      RoomInterface.entity.addEntity(RoomInterface.map);
    });
  }
});// @hash v3-648471AE321D45589FECC8CE18B5A55113D85D5E
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture = new function () {
  this.logics = {};
}();// @hash v3-4FDEE50B075A9305089D398214925977C458F73B
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.place = new function () {
  this.enabled = false;
  this.$icon = $('<canvas></canvas>').css({
    "position": "fixed",
    "pointer-events": "none"
  });

  this.start = async function (furniture, finished, direction = null) {
    furniture = await Furnitures.get(furniture);
    if (finished == undefined) console.trace("finished is missing");
    this.furniture = furniture;
    this.map = await SocketMessages.sendCall({
      OnRoomMapStackUpdate: null
    }, "OnRoomMapStackUpdate");
    this.enabled = true;
    this.finished = finished;
    this.entity = new Client.rooms.items.furniture(RoomInterface.entity, furniture.id, direction);
    this.entity.furniture.events.render.push(function () {
      RoomInterface.furniture.place.direction = RoomInterface.furniture.place.entity.furniture.direction;
    });
    this.entity.disable();
    this.entity.alpha = 0.5;
    const renderer = new FurnitureRenderer({
      id: furniture.id,
      size: 1
    }, this.$icon);
    await this.entity.render();
    this.$icon.appendTo(RoomInterface.$element);
    RoomInterface.entity.addEntity(this.entity);
    this.showIcon();
    RoomInterface.cursor.events.hover.push(this.hover);
    RoomInterface.cursor.events.unhover.push(this.unhover);
    RoomInterface.entity.$canvas.bind("wheel", this.scroll);
  };

  this.hover = function (position) {
    const dimensions = RoomInterface.furniture.place.entity.furniture.getDimensions();

    for (let row = 0; row < dimensions.row; row++) {
      if (RoomInterface.furniture.place.map[position.row + row] == undefined) {
        RoomInterface.furniture.place.showIcon();
        return;
      }

      for (let column = 0; column < dimensions.column; column++) {
        if (RoomInterface.furniture.place.map[position.row + row][position.column + column] == undefined) {
          RoomInterface.furniture.place.showIcon();
          return;
        }
      }
    }

    RoomInterface.furniture.place.hideIcon();
    RoomInterface.furniture.place.position = position;
    RoomInterface.furniture.place.entity.setCoordinates(position.row, position.column, RoomInterface.furniture.place.map[position.row][position.column], 0);
    RoomInterface.furniture.place.entity.enable();
  };

  this.showIcon = function () {
    if (RoomInterface.furniture.place.iconShown == true) return;
    RoomInterface.furniture.place.entity.disable();
    RoomInterface.furniture.place.iconShown = true;
    RoomInterface.entity.$canvas.bind("mousemove", RoomInterface.furniture.place.move);
  };

  this.hideIcon = function () {
    if (RoomInterface.furniture.place.iconShown == false) return;
    RoomInterface.furniture.place.iconShown = false;
    RoomInterface.entity.$canvas.unbind("mousemove", RoomInterface.furniture.place.move);
    RoomInterface.furniture.place.$icon.hide();
  };

  this.click = function () {
    RoomInterface.furniture.place.finished(RoomInterface.furniture.place);
  };

  this.move = function (event) {
    RoomInterface.furniture.place.$icon.css({
      "left": event.offsetX,
      "top": event.offsetY
    }).show();
  };

  this.unhover = function () {
    RoomInterface.furniture.place.entity.disable();
    RoomInterface.furniture.place.showIcon();
  };

  this.scroll = async function (event) {
    const direction = event.originalEvent.deltaY < 0 ? 1 : 0;
    RoomInterface.furniture.place.entity.furniture.settings.direction = RoomInterface.furniture.place.entity.furniture.getNextDirection();
    await RoomInterface.furniture.place.entity.furniture.render();
  };

  this.bind = function () {
    RoomInterface.furniture.place.showIcon();
    RoomInterface.cursor.events.hover.push(RoomInterface.furniture.place.hover);
    RoomInterface.cursor.events.unhover.push(RoomInterface.furniture.place.unhover);
    RoomInterface.entity.$canvas.bind("wheel", RoomInterface.furniture.place.scroll);
    RoomInterface.furniture.place.$icon.appendTo(RoomInterface.$element);
  };

  this.unbind = function () {
    RoomInterface.furniture.place.hideIcon();
    RoomInterface.cursor.events.hover.splice(RoomInterface.cursor.events.hover.indexOf(RoomInterface.furniture.place.hover), 1);
    RoomInterface.cursor.events.unhover.splice(RoomInterface.cursor.events.unhover.indexOf(RoomInterface.furniture.place.unhover), 1);
    RoomInterface.entity.$canvas.unbind("wheel", RoomInterface.furniture.place.scroll);
    RoomInterface.furniture.place.$icon.remove();
  };

  this.stop = function () {
    this.enabled = false;
    this.unbind();
    RoomInterface.entity.removeEntity(RoomInterface.furniture.place.entity);
  };
}();// @hash v3-DDA54FFA13D22BF663B330477A829023B729404C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.pickup = new function () {
  this.start = async function (entity) {
    entity.alpha = .5;
    const response = await SocketMessages.sendCall({
      OnRoomFurniturePickup: entity.data.id
    }, "OnRoomFurniturePickup", x => x.id == entity.data.id);
  };
}();// @hash v3-AEE33BC24552A533FCA3A498DC112DF13CE866B2
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.move = new function () {
  this.start = async function (entity) {
    entity.disable();
    RoomInterface.furniture.place.start(entity.data.furniture, function (result) {
      if (result.entity.enabled == false) {
        result.stop();
        entity.enable();
        return;
      }

      result.unbind();
      SocketMessages.sendCall({
        OnRoomFurnitureMove: {
          id: entity.data.id,
          position: {
            row: result.position.row,
            column: result.position.column,
            direction: result.entity.furniture.settings.direction
          }
        }
      }, "OnRoomFurnitureMove").then(function (response) {
        result.stop();
        entity.enable();
        if (response != null) entity.setCoordinates(result.position.row, result.position.column, result.position.depth);
      });
    }, entity.furniture.settings.direction);
  };
}();// @hash v3-D18BD0CF162CD9D7B9A9DA6948AA4081A3B827A0
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.rotate = new function () {
  this.start = async function (entity) {
    await SocketMessages.sendCall({
      OnRoomFurnitureRotate: {
        id: entity.data.id,
        direction: entity.furniture.getNextDirection()
      }
    }, "OnRoomFurnitureRotate", x => x.id == entity.data.id);
  };
}();// @hash v3-7170FDE7D7677C71E9A91DDB54E1C03164E2FC02
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.use = new function () {
  this.start = async function (entity, sprite) {
    if (RoomInterface.furniture.logics[entity.furniture.types.logic] != undefined) RoomInterface.furniture.logics[entity.furniture.types.logic](entity, sprite);else RoomInterface.furniture.logics["furniture_basic"](entity, sprite);
  };
}();// @hash v3-B658A0B60E89487B65AAF774B92860887C478344
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.logics.furniture_multistate = async function (entity) {
  const animation = entity.furniture.getNextAnimation();
  await SocketMessages.sendCall({
    OnRoomFurnitureUse: {
      id: entity.data.id,
      animation
    }
  }, "OnRoomFurnitureUse", x => x == entity.data.id);
  entity.furniture.setAnimation(animation);
};// @hash v3-E6B6C5F4E0155AC0D5924F4B80E260B56F8C4953
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.logics.furniture_custom_stack_height = function (entity) {
  if (entity.dialog != undefined) {
    entity.dialog.show();
    return;
  }

  entity.dialog = new Dialog({
    title: entity.furniture.furniture.title,
    size: {
      width: 240,
      height: 120
    },
    offset: {
      type: "center"
    }
  });
  entity.dialog.events.destroy.push(function () {
    entity.dialog = undefined;
  });
  entity.dialog.show();
};// @hash v3-941817ADFD652F402829153D8334CE75146BD792
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.logics.furniture_basic = async function (entity, sprite) {
  const tag = sprite == undefined ? undefined : sprite.tag;
  await SocketMessages.sendCall({
    OnRoomFurnitureUse: {
      id: entity.data.id,
      tag
    }
  }, "OnRoomFurnitureUse", x => x == entity.data.id);
};// @hash v3-8E8B3C61BFEFFBD9BD27FF1174F1BE98BFB5A29C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.furniture.logics.furniture_video = new function () {
  const entity = new Dialog({
    title: "Room Furniture Video",
    size: {
      width: 800,
      height: 256
    },
    offset: {
      type: "center"
    },
    resizable: true
  });
  entity.events.create.push(function () {
    entity.$content.addClass("room-interface-furniture-video");
    entity.$frame = $('<iframe frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>').appendTo(entity.$content);
    entity.$controls = $('<div class="room-interface-furniture-controls"></div>').appendTo(entity.$content);
    const $input = $('<div class="room-interface-furniture-input">' + '<p class="room-interface-furniture-input-text">https://www.youtube.com/watch?v=</p>' + '</div>').appendTo(entity.$controls);
    const $link = $('<input type="text" placeholder="dQw4w9WgXcQ">').appendTo($input);
    $('<div class="sprite-plus"></div>').appendTo($input).on("click", async function () {
      const value = $link.val();
      if (value.length == 0) return;
      entity.pause();
      const result = await SocketMessages.sendCall({
        OnRoomFurnitureUse: {
          id: entity.data.id,
          video: value,
          action: "add"
        }
      }, "OnRoomFurnitureUse");
      entity.unpause();
      $link.val("");
      if (result) SocketMessages.send({
        OnRoomFurnitureUse: {
          id: entity.data.id
        }
      });
    });
    entity.$videos = $('<div class="room-interface-furniture-videos"></div>').appendTo(entity.$controls);
    entity.$buttons = $('<div class="room-interface-furniture-buttons"></div>').appendTo(entity.$controls);
    $('<div class="room-interface-furniture-player"><i class="sprite-player-previous"></i></div>').appendTo(entity.$buttons).on("click", async function () {
      entity.pause();
      await SocketMessages.sendCall({
        OnRoomFurnitureUse: {
          id: entity.data.id,
          action: "previous"
        }
      }, "OnRoomFurnitureUse");
      entity.unpause();
    });
    $('<div class="room-interface-furniture-player"><i class="sprite-player-stop"></i></div>').appendTo(entity.$buttons).on("click", async function () {
      entity.pause();
      await SocketMessages.sendCall({
        OnRoomFurnitureUse: {
          id: entity.data.id,
          action: "stop"
        }
      }, "OnRoomFurnitureUse");
      entity.unpause();
    });
    $('<div class="room-interface-furniture-player"><i class="sprite-player-pause"></i></div>').appendTo(entity.$buttons).on("click", async function () {
      entity.pause();
      await SocketMessages.sendCall({
        OnRoomFurnitureUse: {
          id: entity.data.id,
          action: "pause"
        }
      }, "OnRoomFurnitureUse");
      entity.unpause();
    });
    $('<div class="room-interface-furniture-player"><i class="sprite-player-next"></i></div>').appendTo(entity.$buttons).on("click", async function () {
      entity.pause();
      await SocketMessages.sendCall({
        OnRoomFurnitureUse: {
          id: entity.data.id,
          action: "next"
        }
      }, "OnRoomFurnitureUse");
      entity.unpause();
    });
  });
  entity.events.show.push(function () {
    entity.$videos.html("");
    const furniture = RoomInterface.furnitures[entity.data.id];
    Furnitures.get(furniture.data.furniture).then(function (info) {//entity.setTitle(info.title);
    });

    for (let index in entity.data.videos) {
      const minutes = Math.floor(entity.data.videos[index].length / 60);
      const seconds = entity.data.videos[index].length - minutes * 60;
      const $video = $('<div class="room-interface-furniture-video-item">' + '<div class="room-interface-furniture-video-item-title"><b>' + entity.data.videos[index].title + '</b></div>' + '<p class="room-interface-furniture-video-item-user">By ' + entity.data.videos[index].author + '</p>' + '<div class="room-interface-furniture-video-item-length">' + minutes + ':' + (seconds < 10 ? "0" + seconds : seconds) + '</div>' + '</div>').appendTo(entity.$videos);
      const $reference = $('<div class="sprite-reference"></div>').appendTo($video.find(".room-interface-furniture-video-item-title"));
      $reference.on("click", function () {
        window.open("https://www.youtube.com/watch?v=" + entity.data.videos[index].id);
      });
      $video.on("click", function (e) {
        if (!$(e.target).hasClass("room-interface-furniture-video-item")) return;
        $video.parent().find(".room-interface-furniture-video-item.active").removeClass("active");
        $video.addClass("active");
        entity.$frame[0].src = "https://www.youtube.com/embed/" + entity.data.videos[index].id;
      });
      const $cross = $('<div class="sprite-cross"></div>').appendTo($video);
      $cross.on("click", async function () {
        entity.pause();
        await SocketMessages.sendCall({
          OnRoomFurnitureUse: {
            id: entity.data.id,
            video: entity.data.videos[index].id,
            action: "remove"
          }
        }, "OnRoomFurnitureUse");
        entity.$frame[0].src = "";
        $video.remove();
        entity.unpause();
      });
    }

    entity.$videos.find(".room-interface-furniture-video-item").first().click();
  });
  return entity;
}();
SocketMessages.register("OnRoomFurnitureVideoUse", function (data) {
  RoomInterface.furniture.logics.furniture_video.data = data;
  RoomInterface.furniture.logics.furniture_video.show();
});// @hash v3-6DB2DD7A9174D50C79A6692C2F4F2E3B3174EAEE
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomInterface.camera = new function () {
  const entity = new CameraDialog({
    title: "Room Camera",
    size: {
      width: 340,
      height: 462
    },
    offset: {
      type: "center"
    }
  });
  return entity;
}();// @hash v3-F7F2627E03FC6F3581E9402BA7E2BCF014719319
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.rooms.navigator = new function () {
  const entity = new Dialog({
    title: "Room Navigator",
    size: {
      width: 420,
      height: "auto"
    },
    offset: {
      type: "center",
      top: -250
    },
    resizable: true
  });
  entity.events.create.push(function () {
    entity.header = new DialogHeader();
    entity.header.$element.appendTo(entity.$content);
    entity.tabs = new DialogTabs(400);
    entity.tabs.add("public", "Public", function ($element) {
      entity.header.setTitle("Public Lounges!");
      entity.header.setDescription("");
      entity.header.setIcon($('<div class="room-navigator-public-sprite"></div>'));
    });
    entity.tabs.add("all_rooms", "All Rooms", function ($element) {
      entity.header.setTitle("Explore a new room!");
      entity.header.setDescription("Explore a new culture with each and every room you enter and meet different kind of people!");
      entity.header.setIcon($('<div class="room-navigator-explore-sprite"></div>'));
    });
    entity.tabs.add("events", "Events", function ($element) {
      entity.header.setTitle("Publish an event!");
      entity.header.setDescription("Public an event to advertise your room and gain interest!");
      entity.header.setIcon($('<div class="room-navigator-event-sprite"></div>'));
    });
    entity.tabs.add("my_rooms", "My Rooms", async function ($element) {
      entity.header.setTitle("Create your own room!");
      entity.header.setDescription("Create and furnish your own room to just your likings and show it off to your friends!");
      entity.header.setIcon($('<div class="room-navigator-create-sprite"></div>'));
    });
    entity.tabs.click(async function (identifier, $element) {
      entity.pause();
      const rooms = await SocketMessages.sendCall({
        "OnRoomNavigatorUpdate": identifier
      }, "OnRoomNavigatorUpdate");

      for (let key in rooms) {
        const list = new Client.rooms.navigator.list({
          title: key,
          active: true
        });
        rooms[key] = rooms[key].sort(function (a, b) {
          if (a.users == undefined) return 1;
          if (b.users == undefined) return -1;
          return b.users - a.users;
        });

        for (let index in rooms[key]) list.add(rooms[key][index]);

        list.$element.appendTo($element);
      }

      entity.unpause();
    });
    entity.$home = $('<div class="room-navigator-tab-icon room-navigator-tab-home"></div>').on("click", function () {
      SocketMessages.send({
        OnRoomNavigatorEnter: Client.user.home
      });
    }).appendTo(entity.tabs.$header);
    entity.$create = $('<div class="room-navigator-tab-icon room-navigator-tab-create"></div>').on("click", function () {
      RoomCreation.toggle();
    }).appendTo(entity.tabs.$header);
    entity.tabs.show("my_rooms");
    entity.tabs.$element.appendTo(entity.$content);
  });
  entity.events.show.push(function () {
    //if(Client.user.home == null)
    entity.$home.hide(); //else
    //    entity.$home.show();

    entity.tabs.show();
  });
  return entity;
}();// @hash v3-933C6FC98C8BC8D488C651AD57B9D2DE70032C73
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.rooms.navigator.list = function (settings) {
  this.$element = $('<div class="room-navigator-list">' + '<div class="room-navigator-list-header">' + '<div class="room-navigator-list-toggle"></div>' + '<p class="room-navigator-list-title"></p>' + '<div class="room-navigator-list-expand"></div>' + '</div>' + '</div>');
  this.$table = $('<div class="room-navigator-list-table"></div>').appendTo(this.$element);
  this.settings = {
    active: false,
    title: "",
    count: 0,
    collapsed: false
  };

  this.set = function (settings) {
    if (settings.title != undefined) this.$element.find(".room-navigator-list-title").html(settings.title);

    if (settings.active != undefined) {
      if (settings.active) this.$element.attr("active", "");else this.$element.removeAttr("active");
    }

    for (let key in settings) this.settings[key] = settings[key];
  };

  this.set(settings);

  this.add = function (settings) {
    const room = {
      users: 0,
      title: "Unknown title..."
    };

    for (let key in settings) room[key] = settings[key];

    let color = "#CAC9C0";

    if (room.users > 0) {
      color = "#62B061";
    }

    this.settings.count++;
    const $element = $('<div class="room-navigator-list-item">' + '<div class="room-navigator-list-users" style="background: ' + color + '">' + '<p class="room-navigator-list-users-count">' + '<i></i>' + room.users + '</p>' + '</div>' + room.title + '</div>').appendTo(this.$table);
    Game.getUser(room.user).then(function (user) {
      $('<div class="room-navigator-list-owner">By ' + user.name + '</div>').appendTo($element);
    });
    $element.click(async function () {
      SocketMessages.send({
        OnRoomNavigatorEnter: room.id
      });
    });

    if (this.settings.count > 10) {
      this.$expandButton.show();
      $element.addClass("room-navigator-list-expanded");
    }
  };

  this.$expandButton = this.$element.find(".room-navigator-list-expand").on("click", {
    list: this
  }, function (event) {
    const list = event.data.list;

    if (list.settings.collapsed) {
      list.$table.find(".room-navigator-list-expanded").hide();
      $(this).removeAttr("active");
    } else {
      list.$table.find(".room-navigator-list-expanded").show();
      $(this).attr("active", "");
    }

    list.settings.collapsed = !list.settings.collapsed;
  });
  this.$element.find(".room-navigator-list-toggle").on("click", {
    list: this
  }, function (event) {
    const list = event.data.list;
    list.set({
      active: !list.settings.active
    });
  });
};// @hash v3-0C559E0DDDBB1BAC175DA62FE4D5CEEDC9A2A96C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnRoomNavigatorEnter", function (response) {});// @hash v3-063BD4554C17813C6E887C5D9B14F4B0D1D2112F
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomCreation = new function () {
  const entity = new Dialog({
    title: "Room Creation",
    size: {
      width: 580,
      height: 310
    },
    offset: {
      type: "center"
    }
  });
  entity.events.create.push(function () {
    entity.$element.css("overflow", "initial");
    entity.$content.addClass("room-creation");
  });

  entity.showProperties = async function () {
    entity.settings.properties = {};
    entity.$content.html("");
    const $grid = $('<div class="room-creation-grid"></div>').appendTo(entity.$content);
    const $buttons = $('<div class="room-creation-buttons"></div>').appendTo(entity.$content);
    const $information = $('<div class="room-creation-information"></div>').appendTo($grid);
    $('<div class="room-creation-property">' + '<p>' + '<b>Room Name</b>' + '<span>Give your room a fun and interesting title, this is what interests others!</span>' + '</p>' + '<div class="input-pen">' + '<input type="text" class="room-creation-name" placeholder="Enter a room name...">' + '</div>' + '</div>').appendTo($information).find(".room-creation-name").on("change", function () {
      entity.settings.properties.title = $(this).val();
    });
    $('<div class="room-creation-property">' + '<p>' + '<b>Room Description</b>' + '<span>Describe what your room is, what can others do in your room, let them know what it is!</span>' + '</p>' + '<div class="textarea-pen">' + '<textarea type="text" class="room-creation-description" placeholder="Enter a room name..."></textarea>' + '</div>' + '</div>').appendTo($information).find(".room-creation-description").on("change", function () {
      entity.settings.properties.description = $(this).val();
    });
    const $category = $('<div class="room-creation-property">' + '<p>' + '<b>Room Category</b>' + '<span>What category does your room fall into?</span>' + '</p>' + '</div>').appendTo($information);
    const list = [];
    const categories = await RoomCategories.get();

    for (let index in categories) list.push({
      text: categories[index].name,
      value: categories[index].id
    });

    const selection = new DialogSelection("Select a room category...", list);
    $category.append(selection.$element);
    const $privacy = $('<div class="room-creation-privacy"></div>').appendTo($grid);
    const $locks = $('<div class="room-creation-property">' + '<p>' + '<b>Room Privacy</b>' + '<span>Select whether you want a public, private, or passworded room!</span>' + '</p>' + '<div class="input-lock">' + '<input class="room-creation-password disabled" type="text" placeholder="Enter a room password...">' + '</div>' + '<div class="room-creation-privacy-selection">' + '<div class="room-creation-privacy-option active" value="0">' + '<div class="room-creation-privacy-public"></div>' + '</div>' + '<div class="room-creation-privacy-option" value="1">' + '<div class="room-creation-privacy-private"></div>' + '</div>' + '<div class="room-creation-privacy-option" value="2">' + '<div class="room-creation-privacy-password"></div>' + '</div>' + '</div>' + '</div>').appendTo($privacy);
    const $password = $locks.find(".room-creation-password");
    $locks.find(".room-creation-privacy-option").on("click", function () {
      $locks.find(".room-creation-privacy-option.active").removeClass("active");
      $(this).addClass("active");
      if ($(this).attr("value") != 2) $password.addClass("disabled");else $password.removeClass("disabled");
    });
    const $continue = $('<div class="dialog-button">Continue »</div>').appendTo($buttons);
    $continue.click(function () {
      RoomCreation.showMap();
    });
  };

  entity.showMap = async function () {
    entity.$content.html("");
    entity.settings.map = {};
    const models = await SocketMessages.sendCall({
      OnRoomModelsUpdate: null
    }, "OnRoomModelsUpdate");
    const tabs = new DialogTabs(231);
    tabs.add("default", "Default Maps", function ($element) {
      if (RoomCreation.editor != undefined) {
        RoomCreation.editor.destroy();
        RoomCreation.editor = undefined;
      }

      $element.parent().css("overflow", "auto");
      const $models = $('<div class="room-creation-models"></div>').appendTo($element);

      for (let index in models) {
        const map = models[index].map.split('|');
        let tiles = 0;

        for (let row in map) for (let column in map[row]) {
          if (map[row][column] != 'X') tiles++;
        }

        const $element = $('<div class="dialog-item room-creation-model">' + '<p class="room-creation-model-tiles">' + tiles + ' tiles</div>' + '</div>').appendTo($models);
        const $canvas = new RoomCreationMap(map, models[index].door).prependTo($element);
        $element.on("click", function () {
          $models.find(".room-creation-model.active").removeClass("active");
          $element.addClass("active");
          entity.settings.map = models[index];
        });
        if (entity.settings.map.id == undefined || entity.settings.map.id == models[index].id) $element.click();
      }
    });
    tabs.add("editor", "Map Editor", function ($element) {
      $element.parent().css("overflow", "visible");
      const $grid = $('<div class="room-creation-map"></div>').appendTo($element);
      const $settings = $('<div class="room-creation-properties"></div>').css({
        "display": "grid",
        "padding-bottom": "12px"
      }).appendTo($grid);
      $('<div class="room-creation-property">' + '<p>' + '<b>Map Editor</b>' + '<span>Use your mouse on the renderer to the left!</span><br><br>' + '<span>Hold shift and left click to use the current selected tool on the editor.</span><br><br>' + '<span>Press right click to copy the depth of an existing tile on the editor.</span>' + '</p>' + '</div>').appendTo($settings);
      const $toolsProperty = $('<div class="room-creation-property">' + '<p>' + '<b>Map Tools</b>' + '<span>Select what tool you want to use on the editor:</span>' + '</p>' + '<div class="room-creation-editor-tools"></div>' + '</div>').css("margin", "auto 0 0").appendTo($settings);
      const $tools = $toolsProperty.find(".room-creation-editor-tools");
      console.log(entity.settings.map);
      const data = {
        map: entity.settings.map.map.split('|'),
        door: {
          row: entity.settings.map.door.row,
          column: entity.settings.map.door.column
        }
      };
      const editor = new Client.rooms.editor(data, function (map) {
        entity.settings.map.map = map; //const $canvas = new RoomCreationMap(map.split('|'), entity.settings.map.door);
        //$settings.html($canvas);
      });
      RoomCreation.editor = editor;
      editor.tiles.$element.css({
        "width": "280px",
        "height": "230px"
      });
      editor.tiles.$element.prependTo($grid);
      editor.depth.$element.css({
        "width": "280px",
        "height": "24px"
      });
      editor.depth.$element.appendTo(editor.tiles.$element);
      editor.depth.render();
      const $add = $('<div class="dialog-item" value="0"></div>').appendTo($tools).append(editor.tools.$add);
      const $remove = $('<div class="dialog-item" value="1"></div>').appendTo($tools).append(editor.tools.$remove);
      const $up = $('<div class="dialog-item" value="2"></div>').appendTo($tools).append(editor.tools.$up);
      const $down = $('<div class="dialog-item" value="3"></div>').appendTo($tools).append(editor.tools.$down);
      const $door = $('<div class="dialog-item" value="4"></div>').appendTo($tools).append(editor.tools.$door);
      $tools.on("click", ".dialog-item", function () {
        $tools.find(".dialog-item.active").removeClass("active");
        $(this).addClass("active");
        editor.tools.setTool($(this).attr("value"));
      });
      $add.click();
    });
    tabs.show("default");
    tabs.$element.appendTo(entity.$content);
    const $buttons = $('<div class="room-creation-buttons"></div>').appendTo(entity.$content);
    $('<div class="dialog-button">« Back</div>').appendTo($buttons).on("click", function () {
      entity.showProperties();
    });
    const $continue = $('<div class="dialog-button">Continue »</div>').appendTo($buttons);
    $continue.on("click", async function () {
      await SocketMessages.sendCall({
        OnRoomModelCreate: entity.settings
      }, "OnRoomModelCreate");
      entity.hide();
    });
  };

  entity.events.show.push(function () {
    Client.rooms.navigator.hide();
    entity.settings = {};
    entity.showProperties();
  });
  entity.events.destroy.push(function () {
    if (RoomCreation.editor != undefined) {
      RoomCreation.editor.destroy();
      RoomCreation.editor = undefined;
    }
  });
  return entity;
}();// @hash v3-484835D0F4F0450D0653CBA900E1FB4E2BD70240
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
RoomCreationMap = function (input, door) {
  const $canvas = $('<canvas></canvas>');
  const context = $canvas[0].getContext("2d");
  let map = [],
      rows = input.length,
      columns = 0,
      maxDepth = 0;

  for (let row in input) {
    if (input[row].length > columns) columns = input[row].length;
    map[row] = [];

    for (let column in input[row]) {
      if (input[row][column] == 'X') {
        map[row][column] = 'X';
        continue;
      }

      map[row][column] = !Client.utils.isLetter(input[row][column]) ? parseInt(input[row][column]) : Client.utils.fromCharCode(input[row][column]);
      if (map[row][column] > maxDepth) maxDepth = map[row][column];
    }
  }

  context.canvas.width = rows * 4 + columns * 4 + 2;
  context.canvas.height = rows * 2 + columns * 2 + maxDepth * 4 + 6 + 2;
  context.imageSmoothingEnabled = false;

  for (let row in map) {
    for (let column in map[row]) {
      if (map[row][column] == 'X') continue;
      if (door.row == row && door.column == column) continue;
      const depth = map[row][column];
      let left = 0,
          top = 0,
          hasPrevious = false;
      context.setTransform(1, .5, -1, .5, rows * 4 + 4, maxDepth * 4 + 6 + 1);
      context.fillStyle = "#A57B51";
      left = column * 4 - depth * 4;
      top = row * 4 - depth * 4;
      context.fillRect(left, top, 4.5, 4.5);
      hasPrevious = false;

      for (let previousColumn = column - 1; previousColumn != -1; previousColumn--) {
        if (map[row][previousColumn] == undefined || map[row][previousColumn] == 'X') {
          for (let previousRow = row - 1; previousRow != -1; previousRow--) {
            if (map[previousRow] == undefined || map[previousRow][previousColumn] == 'X') continue;
            if (door.row == previousRow && door.column == previousColumn) continue;
            hasPrevious = true;
            break;
          }

          if (hasPrevious) break;
          continue;
        }

        if (door.row == row && door.column == previousColumn) continue;
        hasPrevious = true;
        break;
      }

      if (!hasPrevious) {
        context.setTransform(1, -.5, 0, 1, rows * 4 + 4, maxDepth * 4 + 6 + 1);
        context.fillStyle = "#D48612";
        left = -(row * 4) + (column - 1) * 4;
        top = (column - 1) * 4 - depth * 4;
        context.fillRect(left, top - 5.5, 4.5, door.row == row && door.column == parseInt(column) - 1 ? 1 : 9);
      }

      hasPrevious = false;

      for (let previousRow = row - 1; previousRow != -1; previousRow--) {
        if (map[previousRow] == undefined || map[previousRow][column] == 'X') {
          for (let previousColumn = column - 1; previousColumn != -1; previousColumn--) {
            if (map[previousRow][previousColumn] == undefined || map[previousRow][previousColumn] == 'X') continue;
            if (door.row == previousRow && door.column == previousColumn) continue;
            hasPrevious = true;
            break;
          }

          if (hasPrevious) break;
          continue;
        }

        if (door.row == previousRow && door.column == column) continue;
        hasPrevious = true;
        break;
      }

      if (!hasPrevious) {
        context.setTransform(1, .5, 0, 1, rows * 4 + 4, maxDepth * 4 + 6 + 1);
        context.fillStyle = "#F0C032";
        left = column * 4 - row * 4;
        top = row * 4 - depth * 4;
        context.fillRect(left, top - 9.5, 4.5, door.row == parseInt(row) - 1 && door.column == column ? 1 : 9);
      }
    }
  }

  context.resetTransform();
  context.globalCompositeOperation = "destination-over";
  context.filter = "brightness(0%)";
  context.globalAlpha = .75;
  context.drawImage(context.canvas, 1, 0);
  context.drawImage(context.canvas, -1, 0);
  context.drawImage(context.canvas, 0, 1);
  return $canvas;
};// @hash v3-E98871BE1C85A88017C1513850BDADFE2735CC93
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.rooms.editor = function (settings, change) {
  let editorDepth = 0,
      editorTool = 0;
  this.tiles = new function () {
    this.$element = $('<div class="room-editor-tiles"></div>');
    const $canvas = $('<canvas></canvas>').appendTo(this.$element);
    let map = settings.map,
        rows = map.length,
        columns = 0,
        renderOffset = {
      left: 0,
      top: 0
    };

    for (let row in map) {
      map[row] = map[row].split('');
      if (map[row].length > columns) columns = map[row].length;

      for (let column in map[row]) {
        if (map[row][column] == 'X') continue;
        map[row][column] = !Client.utils.isLetter(map[row][column]) ? parseInt(map[row][column]) : Client.utils.fromCharCode(map[row][column]);
      }
    }

    const render = function (canvas) {
      const context = $canvas[0].getContext("2d");
      context.canvas.width = $canvas.parent().width();
      context.canvas.height = $canvas.parent().height();
      renderOffset = {
        left: canvas.offset.left,
        top: canvas.offset.top
      };
      context.setTransform(1, .5, -1, .5, renderOffset.left, renderOffset.top);

      for (let row in map) {
        for (let column in map[row]) {
          if (map[row][column] == 'X') continue;
          context.fillStyle = "hsl(" + (360 - 360 / 100 * (34 + map[row][column] * 2.5)) + ", 100%, 50%)";
          context.fillRect(parseInt(column) * 16, parseInt(row) * 16, 15.5, 15.5);
        }
      }

      context.strokeStyle = "white";
      context.lineWidth++;
      context.strokeRect(settings.door.column * 16, settings.door.row * 16, 15.5, 15.5);
    };

    const canvas = Canvas.addCanvas($canvas[0], {
      render,
      draggable: true,
      offset: {
        left: $canvas[0].width / 2,
        top: $canvas[0].height / 2 - rows * 4
      }
    });
    this.canvas = canvas;
    let down = false,
        lastCoordinate = {
      row: null,
      column: null
    },
        timestamp = performance.now();
    $canvas.on("mousedown", function () {
      if (canvas.draggableEnabled && performance.now() - canvas.draggableTimestamp > 200) return;
      if (!Keys.down["ShiftLeft"]) return;
      down = true;
    }).on("mouseup", function () {
      down = false;
    }).on("mousemove click", function (event) {
      const innerPosition = {
        left: (event.offsetX - canvas.offset.left) * 0.5 + (event.offsetY - canvas.offset.top),
        top: (event.offsetX - canvas.offset.left) * -0.5 + (event.offsetY - canvas.offset.top)
      };
      const coordinate = {
        row: Math.floor(innerPosition.top / 16),
        column: Math.floor(innerPosition.left / 16)
      };

      if (event.type == "mousemove") {
        if (!down) return;
        if (performance.now() - timestamp < 10) return;
        timestamp = performance.now();
        if (lastCoordinate.row == coordinate.row && lastCoordinate.column == coordinate.column) return;
        lastCoordinate = coordinate;
      } else if (!Keys.down["ShiftLeft"]) return;

      let extra = null;

      if (editorTool == 0) {
        if (map[coordinate.row] == undefined) {
          map[coordinate.row] = [];

          if (coordinate.row < 0) {
            canvas.offset.top -= 8;
            canvas.offset.left += 16;
          }
        } else if (map[coordinate.row][coordinate.column] == undefined) {
          let hasColumn = false;

          for (let row in map) for (let column in map[row]) {
            if (parseInt(column) == coordinate.column) {
              hasColumn = true;
              break;
            }
          }

          if (!hasColumn) {
            if (coordinate.column < 0) {
              canvas.offset.top -= 8;
              canvas.offset.left -= 16;
            }
          }
        }

        extra = {
          rows: 0,
          columns: 0
        };

        if (coordinate.row >= 0) {
          if (coordinate.column >= 0) {
            if (map[coordinate.row][coordinate.column] == editorDepth) return;
          }

          for (let row = coordinate.row - 1; row != -1; row--) if (map[row] == undefined) map[row] = [];
        } else {
          const margin = coordinate.row * -1;
          extra.rows = margin;
          const newMap = [];
          settings.door.row += margin;

          for (let row in map) newMap[parseInt(row) + margin] = map[row];

          coordinate.row = 0;

          for (let row = 0; row != margin; row++) if (newMap[row] == undefined) newMap[row] = [];

          map = newMap;
        }

        if (coordinate.column >= 0) {
          for (let column = coordinate.column - 1; column != -1; column--) {
            if (map[coordinate.row][column] == undefined) map[coordinate.row][column] = 'X';
          }
        } else {
          const margin = coordinate.column * -1;
          extra.columns = margin;
          settings.door.column += margin;

          for (let row in map) {
            const newMap = [];

            for (let column in map[row]) newMap[margin + parseInt(column)] = map[row][column];

            for (let column = 0; column != margin; column++) if (newMap[column] == undefined) newMap[column] = 'X';

            map[row] = newMap;
          }

          coordinate.column += margin;
        }

        map[coordinate.row][coordinate.column] = editorDepth;
      } else if (editorTool == 1) {
        if (map[coordinate.row] == undefined) return;
        if (map[coordinate.row][coordinate.column] == undefined) return;
        if (map[coordinate.row][coordinate.column] == 'X') return;
        map[coordinate.row][coordinate.column] = 'X';
      } else if (editorTool == 2) {
        if (map[coordinate.row] == undefined) return;
        if (map[coordinate.row][coordinate.column] == undefined) return;
        if (map[coordinate.row][coordinate.column] == 24) return;
        if (map[coordinate.row][coordinate.column] == 'X') return;
        map[coordinate.row][coordinate.column]++;
      } else if (editorTool == 3) {
        if (map[coordinate.row] == undefined) return;
        if (map[coordinate.row][coordinate.column] == undefined) return;
        if (map[coordinate.row][coordinate.column] == 0) return;
        if (map[coordinate.row][coordinate.column] == 'X') return;
        map[coordinate.row][coordinate.column]--;
      } else if (editorTool == 4) {
        if (map[coordinate.row] == undefined) return;
        if (map[coordinate.row][coordinate.column] == undefined) return;
        if (map[coordinate.row][coordinate.column] == 'X') return;
        if (coordinate.row == settings.door.row && coordinate.column == settings.door.column) return;
        settings.door.row = coordinate.row;
        settings.door.column = coordinate.column;
      }

      rows = map.length, columns = 0;

      for (let row in map) for (let column in map[row]) {
        if (column > columns) columns = column;
      }

      for (let row in map) {
        for (let column = 0; column <= columns; column++) {
          if (map[row][column] == undefined) map[row][column] = 'X';
        }
      }

      let result = "";

      for (let row in map) {
        if (result.length != 0) result += "|";

        for (let column in map[row]) {
          if (map[row][column] != 'X' && parseInt(map[row][column]) > 10) result += Client.utils.charCode(parseInt(map[row][column]) - 10);else result += map[row][column];
        }
      }

      change(result, extra);
    });
  }();
  this.depth = new function () {
    this.$element = $('<div class="room-editor-depth"></div>');
    const $canvas = $('<canvas></canvas>').appendTo(this.$element);
    const $cursor = $('<div class="room-editor-depth-cursor"></div>').appendTo(this.$element);

    const setCursor = function (depth) {
      const width = $canvas.parent().width() / 24;
      $cursor.css("left", width / 2 + width * depth);
      editorDepth = depth;
    };

    this.render = function () {
      const context = $canvas[0].getContext("2d");
      context.canvas.width = $canvas.parent().width();
      context.canvas.height = $canvas.parent().height();
      const steps = 24,
            width = context.canvas.width / steps;

      for (let index = 0; index < steps; index++) {
        context.fillStyle = "hsl(" + (360 - 360 / 100 * (34 + index * 2.5)) + ", 100%, 50%)";
        const path = new Path2D();
        path.rect(width * index, 0, width + .5, context.canvas.height);
        paths[index] = path;
        context.fill(path);
      }

      setCursor(editorDepth);
    };

    let paths = {},
        down = false;
    this.$element.on("mousedown", function (event) {
      down = true;
      const context = $canvas[0].getContext("2d");

      for (let depth in paths) {
        if (!context.isPointInPath(paths[depth], event.offsetX, event.offsetY)) continue;
        setCursor(depth);
        break;
      }
    }).on("mousemove", function (event) {
      if (!down) return;
      const context = $canvas[0].getContext("2d");

      for (let depth in paths) {
        if (!context.isPointInPath(paths[depth], event.offsetX, event.offsetY)) continue;
        setCursor(depth);
        break;
      }
    }).on("mouseup", function () {
      down = false;
    });
  }();
  this.tools = new function () {
    this.$add = $('<div class="room-editor-tile-add"></div>');
    this.$remove = $('<div class="room-editor-tile-remove"></div>');
    this.$up = $('<div class="room-editor-tile-up"></div>');
    this.$down = $('<div class="room-editor-tile-down"></div>');
    this.$door = $('<div class="room-editor-door"></div>');

    this.setTool = function (tool) {
      editorTool = tool;
    };
  }();

  this.destroy = function () {
    this.tiles.canvas.destroy();
  };
};// @hash v3-49D7E03C3D767734ECD7B693A9889D5F52D7A940
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.rooms.settings = new function () {
  const entity = new Dialog({
    title: "Room Settings",
    size: {
      width: 580,
      height: 310
    },
    offset: {
      type: "center"
    },
    resizable: true
  });
  entity.events.create.push(function () {
    entity.$content.addClass("room-creation");
    const tabs = new DialogTabs("100%");
    tabs.$element.addClass("room-creation-tabs");
    tabs.add("information", "Information", async function ($element) {
      const $grid = $('<div class="room-creation-grid"></div>').appendTo($element);
      const $information = $('<div class="room-creation-information"></div>').appendTo($grid);
      $('<div class="room-creation-property">' + '<p>' + '<b>Room Name</b>' + '<span>Give your room a fun and interesting title, this is what interests others!</span>' + '</p>' + '<div class="input-pen">' + '<input type="text" class="room-creation-name" placeholder="Enter a room name..." value="' + RoomInterface.data.title + '">' + '</div>' + '</div>').appendTo($information).find(".room-creation-name").on("change", function () {
        SocketMessages.send({
          OnRoomSettingsUpdate: {
            title: $(this).val()
          }
        });
      });
      $('<div class="room-creation-property">' + '<p>' + '<b>Room Description</b>' + '<span>Describe what your room is, what can others do in your room, let them know what it is!</span>' + '</p>' + '<div class="textarea-pen">' + '<textarea type="text" class="room-creation-description" placeholder="Enter a room description...">' + RoomInterface.data.description + '</textarea>' + '</div>' + '</div>').appendTo($information).find(".room-creation-description").on("change", function () {
        SocketMessages.send({
          OnRoomSettingsUpdate: {
            description: $(this).val()
          }
        });
      });
    });
    tabs.add("map", "Map Editor", function ($element) {
      $element.parent().css("overflow", "visible");
      const $grid = $('<div class="room-creation-map"></div>').appendTo($element);
      const $settings = $('<div class="room-creation-properties"></div>').css({
        "display": "grid",
        "padding-bottom": "12px"
      }).appendTo($grid);
      $('<div class="room-creation-property">' + '<p>' + '<b>Map Editor</b>' + '<span>Use your mouse on the renderer to the left!</span><br><br>' + '<span>Hold shift and left click to use the current selected tool on the editor.</span><br><br>' + '<span>Press right click to copy the depth of an existing tile on the editor.</span>' + '</p>' + '</div>').appendTo($settings);
      const $toolsProperty = $('<div class="room-creation-property">' + '<p>' + '<b>Map Tools</b>' + '<span>Select what tool you want to use on the editor:</span>' + '</p>' + '<div class="room-creation-editor-tools"></div>' + '</div>').css("margin", "auto 0 0").appendTo($settings);
      const $tools = $toolsProperty.find(".room-creation-editor-tools");
      const data = {
        map: [],
        door: {
          row: RoomInterface.data.map.door.row,
          column: RoomInterface.data.map.door.column
        }
      };

      for (let row in RoomInterface.data.map.floor) data.map[row] = RoomInterface.data.map.floor[row];

      entity.editor = new Client.rooms.editor(data, async function (map, extra) {
        //entity.settings.map.map = map;
        //const $canvas = new RoomCreationMap(map.split('|'), entity.settings.map.door);
        //$settings.html($canvas);
        SocketMessages.send({
          OnRoomSettingsUpdate: {
            map: {
              floor: map,
              extra
            }
          }
        });
      });
      entity.editor.tiles.$element.css({
        "width": "auto",
        "height": "230px"
      });
      entity.editor.tiles.$element.prependTo($grid);
      entity.editor.depth.$element.css({
        "width": "280px",
        "height": "24px"
      });
      entity.editor.depth.$element.appendTo(entity.editor.tiles.$element);
      entity.editor.depth.render();
      const $add = $('<div class="dialog-item" value="0"></div>').appendTo($tools).append(entity.editor.tools.$add);
      const $remove = $('<div class="dialog-item" value="1"></div>').appendTo($tools).append(entity.editor.tools.$remove);
      const $up = $('<div class="dialog-item" value="2"></div>').appendTo($tools).append(entity.editor.tools.$up);
      const $down = $('<div class="dialog-item" value="3"></div>').appendTo($tools).append(entity.editor.tools.$down);
      const $door = $('<div class="dialog-item" value="4"></div>').appendTo($tools).append(entity.editor.tools.$door);
      $tools.on("click", ".dialog-item", function () {
        $tools.find(".dialog-item.active").removeClass("active");
        $(this).addClass("active");
        entity.editor.tools.setTool($(this).attr("value"));
      });
      $add.click();
    });
    tabs.add("walls", "Walls", function ($element) {
      const walls = Client.rooms.asset.room_visualization.visualizationData.wallData.walls.wall;
      const $container = $('<div class="room-creation-items"></div>').appendTo($element);
      const $content = $('<div class="room-creation-items-container"></div>').appendTo($container);
      const $items = $('<div class="room-creation-items-content"></div>').appendTo($content);
      const $preview = $('<div class="room-creation-items-preview"></div>').appendTo($container);
      const $canvas = $('<canvas width="200" height="200"></canvas>').appendTo($preview);
      const context = $canvas[0].getContext("2d");

      for (let index = 0; index < walls.length; index++) {
        const $item = $('<div class="dialog-item room-creation-item"></div>').appendTo($items);
        Assets.getSpritesheet("HabboRoomContentIcons/th_wall_" + walls[index].id, false).then(function (image) {
          $(image).appendTo($item);
        });
        $item.on("click", function () {
          $items.find(".room-creation-item.active").removeClass("active");
          $item.addClass("active");
          const map = new Client.rooms.map.entity(["XXXXXXX", "X000000", "X000000", "X000000", "X000000", "X000000", "X000000"], {}, {
            material: RoomInterface.data.floor_material
          }, {
            material: walls[index].id
          });
          map.render().then(function () {
            context.canvas.width = $preview.width();
            context.canvas.height = $preview.height();
            context.drawImage(map.$floor[0], -(8 * 16), 6 * 16 + -(map.depth * 16));
            context.drawImage(map.$wall[0], -(8 * 16), 6 * 16 + map.offset);
          });

          if (RoomInterface.data.wall_material != walls[index].id) {
            SocketMessages.send({
              OnRoomSettingsUpdate: {
                wall: {
                  material: walls[index].id
                }
              }
            });
          }
        });
        if (RoomInterface.data.wall_material == walls[index].id) $item.click();
      }
    });
    tabs.add("floors", "Floors", function ($element) {
      const floors = Client.rooms.asset.room_visualization.visualizationData.floorData.floors.floor;
      const $container = $('<div class="room-creation-items"></div>').appendTo($element);
      const $content = $('<div class="room-creation-items-container"></div>').appendTo($container);
      const $items = $('<div class="room-creation-items-content"></div>').appendTo($content);
      const $preview = $('<div class="room-creation-items-preview"></div>').appendTo($container);
      const $canvas = $('<canvas width="200" height="200"></canvas>').appendTo($preview);
      const context = $canvas[0].getContext("2d");

      for (let index = 0; index < floors.length; index++) {
        const $item = $('<div class="dialog-item room-creation-item"></div>').appendTo($items);
        Assets.getSpritesheet("HabboRoomContentIcons/th_floor_" + floors[index].id, false).then(function (image) {
          $(image).appendTo($item);
        });
        $item.on("click", function () {
          $items.find(".room-creation-item.active").removeClass("active");
          $item.addClass("active");
          const map = new Client.rooms.map.entity(["XXXXXXX", "X000000", "X000000", "X000000", "X000000", "X000000", "X000000"], {}, {
            material: floors[index].id
          }, {
            material: RoomInterface.data.wall_material
          });
          map.render().then(function () {
            context.canvas.width = $preview.width();
            context.canvas.height = $preview.height();
            context.drawImage(map.$floor[0], -(8 * 16), 6 * 16 + -(map.depth * 16));
            context.drawImage(map.$wall[0], -(8 * 16), 6 * 16 + map.offset);
          });

          if (RoomInterface.data.floor_material != floors[index].id) {
            SocketMessages.send({
              OnRoomSettingsUpdate: {
                floor: {
                  material: floors[index].id
                }
              }
            });
          }
        });
        if (RoomInterface.data.floor_material == floors[index].id) $item.click();
      }
    });
    tabs.click(function (identifier, $element) {
      if (entity.editor != undefined) entity.editor.destroy();
      $element.parent().css("overflow", "");
    });
    tabs.show("information");
    tabs.$element.appendTo(entity.$content);
  });
  entity.events.show.push(function () {});
  entity.events.destroy.push(function () {
    if (entity.editor != undefined) entity.editor.destroy();
  });
  return entity;
}();
RoomInterface.events.stop.push(function () {
  Client.rooms.settings.destroy();
});// @hash v3-B42FAAA798F9CD8F728E182B82C733FD58E6C7DF
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Menu = new function () {
  this.$element = $('<div id="menu"></div>').appendTo(Client.$element);
  this.$icons = $('<div class="menu-items"></div>').appendTo(this.$element);

  this.addItem = function (identifier, callback) {
    const $element = $('<div class="menu-item">' + '<div class="menu-sprite menu-' + identifier + '"></div>' + '</div>').on("click", function () {
      callback();
    }).appendTo(this.$icons);
    return $element;
  };

  this.addItem("navigator", function () {
    Client.rooms.navigator.toggle();
  });
  this.addItem("shop", function () {
    Client.shop.toggle();
  });
  const $inventory = this.addItem("inventory", function () {
    Inventory.toggle();
  });
  const $camera = this.addItem("camera", function () {
    RoomInterface.camera.toggle();
  });
  RoomInterface.events.start.push(function () {
    $inventory.show();
    $camera.show();
  });
  RoomInterface.events.stop.push(function () {
    $camera.hide();
    $inventory.hide();
  });
}();
Loader.ready(function () {
  const $user = Menu.addItem("user", function () {
    MenuSub.$element.toggle();
  });
  const $canvas = $('<div class="menu-sprite menu-user"></div>');
  $user.html($canvas);
  const entity = new FigureEntity(Client.user.figure);
  SocketMessages.register("OnUserUpdate", function (data) {
    if (data.figure == undefined) return;
    entity.setFigure(data.figure);
    entity.render();
  });
  entity.events.render.push(function () {
    $canvas.html(entity.$canvas);
  });
  entity.process().then(function () {
    entity.render();
  });
});// @hash v3-183027AEFE0246A2352BBB3CACBABE83B877C7DB
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
MenuSub = new function () {
  this.$element = $('<div class="menu-sub"></div>').appendTo(Client.$element);

  this.addItem = function (sprite, click) {
    const $element = $('<div class="menu-sub-item">' + '<div class="menu-sub-sprite sprite-' + sprite + '"></div>' + '</div>').appendTo(this.$element);
    $element.on("click", click);
  };

  this.addItem("menu-sub-achievements", function () {});
}();// @hash v3-8B4A67470B17013CCDBF75B96030229E14A3348A
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
MenuFriends = new function () {
  this.$element = $('<div class="menu-friends"></div>').appendTo(Menu.$element);
  this.friends = {};

  this.add = function (id) {
    const $element = $('<div class="menu-friend"></div>').appendTo(this.$element);
    Game.getUser(id).then(async function (user) {
      const friend = Client.user.friends[id];
      const $content = $('<div class="menu-friend-content"></div>').appendTo($element);
      const $name = $('<p class="menu-friend-name">' + user.name + '</p>').appendTo($content);
      const $buttons = $('<div class="menu-friend-buttons"></div>').appendTo($content);

      if (friend.status == 0) {
        $element.addClass("menu-friend-request");
      } else {
        $element.click(function (e) {
          if ($(e.target).hasClass("menu-friend-content")) $element.toggleClass("active");
        });
        $('<div class="menu-friend-follow sprite-user-follow"></div>').appendTo($buttons);
      }

      const $figure = $('<div class="menu-friend-figure"></div>').appendTo($content);
      const $canvas = $('<canvas class="menu-friend-figure-canvas" width="256" height="256"></canvas>').appendTo($figure);
      const context = $canvas[0].getContext("2d");
      const entity = new FigureEntity(user.figure);
      entity.events.render.push(function (sprites) {
        context.clearRect(0, 0, 256, 256);

        for (let index in sprites) context.drawImage(sprites[index].image, sprites[index].left, sprites[index].top);
      });
      await entity.process();
      await entity.render();
    });
    return $element;
  };

  RoomInterface.events.stop.push(function () {
    for (let id in Client.user.friends) {
      if (Client.user.friends[id].request == undefined) continue;
      Client.user.friends[id].request.destroy();
      delete Client.user.friends[id].request;
    }
  });
}();// @hash v3-E2DBA3311FAFABF6DA7B9D29262409C5F568C5AC
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.shop = new function () {
  const entity = new Dialog({
    title: "Shop",
    size: {
      width: 580,
      height: 600
    },
    offset: {
      type: "center"
    }
  });
  entity.categories = {};
  entity.types = {};

  entity.setIcon = function (icon) {
    Assets.getSpritesheet("HabboShopIcons/icon_" + icon, false).then(function (spritesheet) {
      const context = entity.$icon[0].getContext("2d");
      context.imageSmoothingEnabled = false;
      const width = spritesheet.width * 3,
            height = spritesheet.height * 3;
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);
      context.drawImage(spritesheet, 0, 0, spritesheet.width, spritesheet.height, (context.canvas.width - width) / 2, (context.canvas.height - height) / 2, width, height);
    });
  };

  entity.setHeader = function (header) {
    const context = entity.header.getContext("2d");

    if (header.length == 0) {
      context.clearRect(0, 0, context.canvas.width, context.canvas.height);
      return;
    }

    Assets.getSpritesheet("HabboShopHeaders/" + header, false).then(function (spritesheet) {
      context.imageSmoothingEnabled = false;
      context.drawImage(spritesheet, 0, 0, spritesheet.width, spritesheet.height, -(spritesheet.width * 2 - 580) / 2, -(spritesheet.height * 2 - 95) / 2, spritesheet.width * 2, spritesheet.height * 2);
    });
  };

  entity.setPage = async function (id) {
    const page = entity.pages.find(x => x.id == id);
    if (!page.data) page.data = await SocketMessages.sendCall({
      OnShopPageUpdate: id
    }, "OnShopPageUpdate");
    Client.development.shop.set(page);
    entity.header.setTitle(page.title);
    entity.header.setDescription(page.data.description ? page.data.description : "");
    entity.setIcon(page.icon);
    entity.setHeader(page.data.header ? page.data.header : "");

    if (page.parent == 0) {
      try {
        entity.category = new Client.shop.categories[page.data.type](page);
      } catch (exception) {
        entity.tabs.$content.html(exception);
      }
    } else {
      try {
        entity.page = await Client.shop.types[page.data.type](page);
      } catch (exception) {
        entity.category.$content.html(exception);
      }
    }
  };

  entity.events.create.push(async function () {
    if (!entity.pages) entity.pages = await SocketMessages.sendCall({
      OnShopUpdate: null
    }, "OnShopUpdate");
    entity.header = new DialogHeader({
      height: 95
    });
    entity.header.$element.appendTo(entity.$content);
    entity.tabs = new DialogTabs(500);
    entity.$icon = $('<canvas width="64" height="64"></canvas>');
    entity.header.setIcon(entity.$icon);
    const categories = entity.pages.filter(x => x.parent == 0);

    for (let index in categories) entity.tabs.add(categories[index].id, categories[index].title);

    entity.tabs.click(entity.setPage);
    entity.tabs.show(categories[0].id);
    entity.tabs.$element.appendTo(entity.$content);
  });
  entity.events.show.push(function () {});
  return entity;
}();// @hash v3-917CF945B27B878AFE5A2489E20AEC93CD68F3AD
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.shop.categories.default = function (page) {
  this.$element = $('<div class="shop-pages">' + '<div class="shop-pages-left">' + '<div class="shop-pages-search input-pen">' + '<input class="shop-pages-search-input" type="text" placeholder="Search...">' + '</div>' + '<div class="shop-pages-list dialog-container">' + '<div class="shop-pages-list-container"></div>' + '</div>' + '</div>' + '<div class="shop-pages-right"></div>' + '</div>');
  this.$search = this.$element.find(".shop-pages-search-input");
  this.$search.on("change", function () {
    Client.shop.category = new Client.shop.categories.search($(this).val());
  });
  this.$list = this.$element.find(".shop-pages-list-container");
  this.$content = this.$element.find(".shop-pages-right");

  this.addPage = function (page, $parent) {
    const $element = $('<div class="shop-pages-item">' + '<div class="shop-pages-item-button">' + '<canvas class="shop-pages-item-icon" width="20" height="20"></canvas>' + page.title + '</div>' + '</div>').appendTo($parent);
    const $button = $element.find(".shop-pages-item-button").on("click", function () {
      $parent.find(".shop-pages-item.active").removeClass("active");
      $element.addClass("active");
      Client.shop.setPage(page.id);
    });
    const $icon = $element.find(".shop-pages-item-icon");
    const context = $icon[0].getContext("2d");
    Assets.getSpritesheet("HabboShopIcons/icon_1", false).then(function (spritesheet) {
      context.drawImage(spritesheet, Math.floor((context.canvas.width - spritesheet.width) / 2), Math.floor((context.canvas.height - spritesheet.height) / 2));
      Assets.getSpritesheet("HabboShopIcons/icon_" + page.icon, false).then(function (spritesheet) {
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(spritesheet, Math.floor((context.canvas.width - spritesheet.width) / 2), Math.floor((context.canvas.height - spritesheet.height) / 2));
      });
    });
    const subPages = Client.shop.pages.filter(x => x.parent == page.id);
    if (subPages.length == 0) return;
    const $list = $('<div class="shop-pages-item-list"></div>').appendTo($element);
    $button.addClass("shop-pages-item-drop").on("click", function () {
      $element.toggleClass("active");
    });

    for (let index in subPages) this.addPage(subPages[index], $list);
  };

  const subPages = Client.shop.pages.filter(x => x.parent == page.id);

  for (let index in subPages) this.addPage(subPages[index], this.$list);

  Client.shop.tabs.$content.html(this.$element);
};// @hash v3-B814C7207865CF8F7FD1A793905D7C7E9C4AA279
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.shop.categories.search = function (input) {
  const $element = $('<div class="shop-pages">' + '<div class="shop-pages-left">' + '<div class="shop-pages-search input-pen">' + '<input class="shop-pages-search-input" type="text" placeholder="Search..." value="' + input + '">' + '</div>' + '<div class="shop-pages-list dialog-container">' + '<div class="shop-pages-list-container"></div>' + '</div>' + '</div>' + '<div class="shop-pages-right"></div>' + '</div>');
  const $search = $element.find(".shop-pages-search-input");
  $search.on("change", function () {
    Client.shop.category = new Client.shop.categories.search($(this).val());
  });
  const $list = $element.find(".shop-pages-list-container");
  this.$content = $element.find(".shop-pages-right");

  const addPage = function (page, $parent) {
    const $element = $('<div class="shop-pages-item">' + '<div class="shop-pages-item-button">' + '<canvas class="shop-pages-item-icon" width="20" height="20"></canvas>' + page.title + '</div>' + '</div>').appendTo($parent);
    const $button = $element.find(".shop-pages-item-button").on("click", function () {
      $parent.find(".shop-pages-item.active").removeClass("active");
      $element.addClass("active");
      Client.shop.setPage(page.id);
    });
    const $icon = $element.find(".shop-pages-item-icon");
    const context = $icon[0].getContext("2d");
    Assets.getSpritesheet("HabboShopIcons/icon_1", false).then(function (spritesheet) {
      context.drawImage(spritesheet, Math.floor((context.canvas.width - spritesheet.width) / 2), Math.floor((context.canvas.height - spritesheet.height) / 2));
      Assets.getSpritesheet("HabboShopIcons/icon_" + page.icon, false).then(function (spritesheet) {
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(spritesheet, Math.floor((context.canvas.width - spritesheet.width) / 2), Math.floor((context.canvas.height - spritesheet.height) / 2));
      });
    });
  };

  SocketMessages.sendCall({
    OnShopSearch: input
  }, "OnShopSearch").then(function (response) {
    for (let index in response.pages) addPage(response.pages[index], $list);

    Client.shop.page = Client.shop.types.default({
      id: null,
      furnitures: response.furnitures
    });
  });
  Client.shop.tabs.$content.html($element);
};// @hash v3-171BE74C24B008DFA689375E4DB6289FBE85B982
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.shop.types.default = async function (page) {
  const $element = $('<div class="shop-furnitures">' + '<div class="shop-furnitures-display"></div>' + '<div class="shop-furnitures-items dialog-container">' + '<div class="shop-furnitures-items-container"></div>' + '</div>' + '</div>');
  const $display = $element.find(".shop-furnitures-display");
  const $items = $element.find(".shop-furnitures-items-container");
  if (!page.furnitures) page.furnitures = await SocketMessages.sendCall({
    OnShopFurnituresUpdate: page.id
  }, "OnShopFurnituresUpdate");

  for (let index in page.furnitures) {
    const furniture = page.furnitures[index].furniture;
    const $item = $('<div class="shop-furnitures-item">' + '<div class="shop-furnitures-item-icon"></div>' + '</div>').appendTo($items);
    const $icon = $item.find(".shop-furnitures-item-icon");
    const $canvas = $('<canvas></canvas>').appendTo($icon);
    const renderer = new FurnitureRenderer({
      id: furniture.id,
      size: 1
    }, $canvas);
    $item.click(async function () {
      $display.html("");
      const $canvas = $('<canvas class="shop-furnitures-display-canvas"></canvas>').appendTo($display);
      new FurnitureRenderer({
        id: furniture.id,
        direction: 4
      }, $canvas, "#e9e9e1");
      const $information = $('<div class="shop-furnitures-display-info">' + '<b>' + furniture.title + '</b>' + '<p>' + furniture.description + '</p>' + '</div>').appendTo($display);
      const $button = $('<div class="dialog-button shop-furnitures-display-button">Add to inventory</div>').appendTo($display);
      $button.click(async function () {
        Client.shop.pause();
        await SocketMessages.sendCall({
          OnShopFurniturePurchase: page.furnitures[index].id
        }, "OnShopFurniturePurchase");
        Client.shop.unpause();
      });
    });
  }

  Client.shop.category.$content.html($element);
};// @hash v3-C36852E3154CB39E14171F0B676D02694E3109BA
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
const Inventory = new Dialog({
  title: "Inventory",
  size: {
    width: 480,
    height: 280
  },
  offset: {
    type: "center"
  },
  resizable: true
});
Inventory.pages = {};
Inventory.events.create.push(async function () {
  Inventory.tabs = new DialogTabs("100%");
  Inventory.tabs.$element.addClass("inventory-tabs");
  Inventory.tabs.add("furnitures", "Furnitures");
  Inventory.tabs.add("badges", "Badges");
  Inventory.tabs.add("pets", "Pets", undefined, true);
  Inventory.tabs.add("bots", "Bots", undefined, true);
  Inventory.tabs.click(async function (identifier, $content) {
    try {
      Inventory.$furnitures = {};
      Inventory.page = Inventory.pages[identifier]($content);
    } catch (exception) {
      $content.html(exception);
    }
  });
  Inventory.tabs.show("furnitures");
  Inventory.tabs.$element.appendTo(Inventory.$content);
});
Inventory.events.show.push(function () {
  if (RoomInterface.furniture.place.enabled == true) {
    RoomInterface.furniture.place.stop();
  }

  Inventory.tabs.show();
});// @hash v3-9EAF2D22A570FD2E647450A87BD2BA4A44BEB824
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Inventory.pages.furnitures = function ($element) {
  $element.html('<div class="inventory-furnitures">' + '<div class="inventory-furnitures-container">' + '<div class="inventory-furnitures-content"></div>' + '</div>' + '<div class="inventory-furniture-display"></div>' + '</div>');
  const $content = $element.find(".inventory-furnitures-content");
  const $display = $element.find(".inventory-furniture-display");

  function setDisplay(furniture) {
    $display.html('<canvas class="inventory-furniture-display-canvas"></canvas>' + '<div class="inventory-furniture-display-information">' + '<b>' + furniture.title + '</b>' + '<p>' + furniture.description + '</p>' + '</div>');

    if (RoomInterface.active == true) {
      const $button = $('<div class="dialog-button">Place in room</div>').appendTo($display.find(".inventory-furniture-display-information"));
      $button.click(function () {
        Inventory.hide();
        RoomInterface.furniture.place.start(furniture.id, function (result) {
          if (result.entity.enabled == false) {
            result.stop();
            Inventory.show();
            return;
          }

          result.unbind();
          SocketMessages.sendCall({
            OnRoomFurniturePlace: {
              id: result.furniture.id,
              position: {
                row: result.position.row,
                column: result.position.column,
                direction: result.entity.furniture.settings.direction
              }
            }
          }, "OnRoomFurniturePlace").then(function (response) {
            if (response == null) {
              result.stop();
              Inventory.show();
              return;
            }

            Client.user.furnitures[furniture.id].inventory--;
            if (Client.user.furnitures[furniture.id].rooms == undefined) Client.user.furnitures[furniture.id].rooms = 0;
            Client.user.furnitures[furniture.id].rooms++;
            setFurniture(furniture.id);

            if (Client.user.furnitures[furniture.id].inventory == 0) {
              result.stop();
              Inventory.show();
              return;
            }

            result.bind();
          });
        });
      });
    }

    const $canvas = $element.find(".inventory-furniture-display-canvas");
    new FurnitureRenderer({
      id: furniture.id,
      direction: 4
    }, $canvas);
  }

  ;

  function setFurniture(id) {
    if (!(Client.user.furnitures[id].inventory > 0)) {
      if (Inventory.$furnitures[id] != undefined) {
        Inventory.$furnitures[id].$element.remove();
        Inventory.$furnitures[id] = undefined;
      }

      return;
    }

    if (Inventory.$furnitures[id] == undefined) {
      Inventory.$furnitures[id] = {
        $element: $('<div class="dialog-item inventory-furniture-icon"></div>').prependTo($content),
        $canvas: $('<canvas class="inventory-furniture-icon-image"></canvas>'),
        $quantity: $('<div class="inventory-furniture-icon-quantity">' + Client.user.furnitures[id].inventory + '</div>')
      };
      Inventory.$furnitures[id].$canvas.appendTo(Inventory.$furnitures[id].$element);
      Inventory.$furnitures[id].$quantity.appendTo(Inventory.$furnitures[id].$element);
    }

    Inventory.$furnitures[id].$quantity.html(Client.user.furnitures[id].inventory);
    if (Client.user.furnitures[id].inventory == 1) Inventory.$furnitures[id].$quantity.hide();else Inventory.$furnitures[id].$quantity.show();
    Furnitures.get(id).then(function (furniture) {
      const renderer = new FurnitureRenderer({
        id: furniture.id,
        size: 1
      }, Inventory.$furnitures[id].$canvas);
      Inventory.$furnitures[id].$element.click(function () {
        Inventory.$furnitures[id].$element.parent().find(".active").removeClass("active");
        Inventory.$furnitures[id].$element.addClass("active");
        setDisplay(furniture);
      });
    });
  }

  ;

  for (let id in Client.user.furnitures) setFurniture(id);
};// @hash v3-8C3EADF5EF16A757C4A15DBE551FD07D4EC43F59
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Inventory.pages.badges = async function ($element) {
  $element.html('<div class="inventory-badges">' + '<div class="inventory-badges-grid">' + '<div class="inventory-badges-container">' + '<div class="inventory-badges-unequipped"></div>' + '</div>' + '<div class="inventory-badges-equipped"></div>' + '</div>' + '<div class="inventory-badges-info">' + '<div class="inventory-badges-info-badge"></div>' + '<div class="inventory-badges-info-content"></div>' + '<div class="inventory-badges-info-button"></div>' + '</div>' + '</div>');
  const $infoBadge = $element.find(".inventory-badges-info-badge");
  const $infoContent = $element.find(".inventory-badges-info-content");
  const $infoButton = $element.find(".inventory-badges-info-button");
  const $uneqipped = $element.find(".inventory-badges-unequipped");
  const $equipped = $element.find(".inventory-badges-equipped");
  const badges = await SocketMessages.sendCall({
    OnUserInventoryBadges: null
  }, "OnUserInventoryBadges");

  for (let index in badges) {
    const $badge = $('<div class="dialog-item inventory-badges-icon"></div>').prependTo(badges[index].equipped ? $equipped : $uneqipped);
    new BadgeRenderer(badges[index].badge).addClass("inventory-badges-icon-image").appendTo($badge);

    async function click() {
      $element.find(".inventory-badges-icon.active").removeClass("active");
      $badge.addClass("active");
      $infoBadge.html(new BadgeRenderer(badges[index].badge));
      const badge = await Badges.get(badges[index].badge);
      $infoContent.html('<b>' + badge.title + '</b>' + '<p>' + badge.description + '</p>');
      $infoButton.html("");
      $('<div class="dialog-button">' + (badges[index].equipped ? "Unequip" : "Equip") + '</div>').appendTo($infoButton).on("click", async function () {
        Inventory.pause();
        const result = await SocketMessages.sendCall({
          OnUserInventoryBadges: {
            id: badges[index].badge
          }
        }, "OnUserInventoryBadges");
        Inventory.unpause();

        if (result == true) {
          badges[index].equipped = !badges[index].equipped;
          $badge.remove().appendTo(badges[index].equipped ? $equipped : $uneqipped).on("click", click).click();
        }
      });
    }

    ;
    $badge.on("click", click);
  }

  let $first = $equipped.find(".inventory-badges-icon");
  if (!$first.length) $first = $uneqipped.find(".inventory-badges-icon");
  $first.first().click();
};// @hash v3-F5436C1CE4764F854F8DD209ABCBE71EEAE5C266
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.user = new function () {
  this.home = null;
  this.furnitures = {};
  this.figure = "hr-100.hd-180-1.ch-210-66.lg-270-82.sh-290-91";
  this.friends = {};
  SocketMessages.register("OnUserUpdate", function (data) {
    for (let key in data) Client.user[key] = data[key];
  });
  SocketMessages.register("OnUserFurnitureUpdate", function (data) {
    for (let key in data) Client.user.furnitures[key] = data[key];

    if (Inventory.active && Inventory.tabs.selected == "furnitures") for (let key in data) Inventory.page.setFurniture(key);
  });
}();// @hash v3-0027CE36666802F90727CE9C2300621815DD0D19
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnUserFriendUpdate", function (data) {
  if (data.length == undefined) data = [data];

  for (let index in data) {
    const id = data[index].id;
    if (Client.user.friends[id] == undefined) Client.user.friends[id] = {};
    if (data[index].status == 0 && Client.user.friends[id].status != data[index].status && Client.user.friends[id].request == undefined && RoomInterface.users[id] != undefined) data[index].request = new RoomInterface.display.users.request(RoomInterface.users[id]);
    if (Client.user.friends[id].menu != undefined) Client.user.friends[id].menu.remove();
    if (data[index].status != -1) data[index].menu = MenuFriends.add(id);

    for (let key in data[index]) Client.user.friends[id][key] = data[index][key];
  }
});// @hash v3-747055C2EC131501CF5663536ACB76DC298F0BE3
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnUserFriendRemove", function (data) {
  if (Client.user.friends[data] == undefined) return;
  if (Client.user.friends[data].request != undefined) Client.user.friends[data].request.destroy();
  if (Client.user.friends[data].menu != undefined) Client.user.friends[data].menu.remove();
  delete Client.user.friends[data];
});// @hash v3-F932869A1406AADE94D534360C367AE6BF63278C
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
SocketMessages.register("OnUserBadgeAdd", function (data) {
  const entity = new DisplayDialog({
    title: "Badge Unlocked"
  });
  entity.show();
  BadgeRenderer(data.badge).css("margin", "auto").appendTo(entity.$display);
  Badges.get(data.badge).then(function (data) {
    entity.$info.html('<h1>Congratulations!</h1>' + '<p>You have received the badge <b>' + data.title + '</b></p>' + '<p>' + data.description + '</p>');
  });
});// @hash v3-5D2D07346EA97CC35DC1D774670ECFB95E10F045
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.theme = new function () {
  this.data = {};

  this.get = function (path, value) {
    const keys = path.split('/');
    let data = this.data;

    for (let index in keys) {
      if (data[keys[index]] == undefined) return value;
      data = data[keys[index]];
    }

    return data;
  };
}();// @hash v3-711E9D82F93FBA8123F80C76806EFC4B2B9DE69E
// Automatically generated by ReactJS.NET. Do not edit, your changes will be overridden.
// Version: 5.2.11 (build 7510121) with Babel 7.8.7
// Generated at: 2021-09-09 12:20:13
///////////////////////////////////////////////////////////////////////////////
Client.utils = new function () {
  this.colors = {
    "Loader": "orange",
    "Assets": "skyblue",
    "Socket": "pink",
    "SocketMessages": "pink"
  };

  this.log = function (header, message, indent = 0, tab = false) {
    const name = header.split(':')[0];

    if (this.colors[name] != undefined) {
      indent = 64 + indent * 32;
      return console.log((tab ? "\t" : "") + "[%c" + header + "%c] %c" + message, "color: " + this.colors[name] + "", "color: inherit", "color: " + (indent != 0 ? "rgba(" + (255 - indent) + ", " + (255 - indent) + ", " + (255 - indent) + ", 1)" : "inherit"));
    }

    return console.log((tab ? "\t" : "") + "[" + header + "] " + message);
  };

  this.warn = function (header, message, tab = false) {
    return console.warn((tab ? "\t" : "") + "[" + header + "] " + message);
  };

  this.error = function (header, message, tab = false) {
    return console.error((tab ? "\t" : "") + "[" + header + "] " + message);
  };

  this.info = function (header, message, tab = false) {
    return console.info((tab ? "\t" : "") + "[" + header + "] " + message);
  };

  this.object = function (header, message, object, tab = false) {
    const name = header.split(':')[0];
    if (this.colors[name] != undefined) return console.log((tab ? "\t" : "") + "[%c" + header + "%c] %c" + message + " %o", "color: " + this.colors[name] + "", "color: inherit", "color: inherit", object);
    return console.log((tab ? "\t" : "") + "[" + header + "] %o", object);
  };

  this.isLetter = function (character) {
    return character.toLowerCase() != character.toUpperCase();
  };

  this.charCode = function (number) {
    return String.fromCharCode(97 + number);
  };

  this.fromCharCode = function (number) {
    return number.charCodeAt(0) - 97;
  };

  this.getArrayMedian = function (array) {
    const newArray = JSON.parse(JSON.stringify(array));
    newArray.sort(function (a, b) {
      return a - b;
    });
    var i = newArray.length / 2;
    return i % 1 == 0 ? (newArray[i - 1] + newArray[i]) / 2 : newArray[Math.floor(i)];
  };

  this.getStringMarkup = function (string) {
    const parts = [{
      type: "Regular",
      message: ""
    }];
    let currentPart = 0;

    for (let character = 0, length = string.length; character < length; character++) {
      let occurances = 0;

      for (let index in string) {
        if (string[index] == '*') occurances++;
      }

      if (string[character] != '*' || occurances == 1) {
        parts[currentPart].message += string[character];
        string = string.substring(character, length);
        character = 0;
        length = string.length;
        continue;
      }

      if (string[character] == '*') {
        if (string[character + 1] == '*') {
          if (character + 2 == length) break;

          if (parts[currentPart].type == "Bold") {
            parts.push({
              type: "Regular",
              message: ""
            });
            currentPart++;
          } else if (parts[currentPart].type != "Bold") {
            parts.push({
              type: "Bold",
              message: ""
            });
            currentPart++;
          }

          character++;
        } else {
          if (character + 1 == length) break;

          if (parts[currentPart].type == "Italic") {
            parts.push({
              type: "Regular",
              message: ""
            });
            currentPart++;
          } else if (parts[currentPart].type != "Italic") {
            parts.push({
              type: "Italic",
              message: ""
            });
            currentPart++;
          }
        }

        string = string.substring(character, length);
        character = 0;
        length = string.length;
      }
    }

    return parts;
  };
}();